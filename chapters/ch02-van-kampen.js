window.CHAPTERS = window.CHAPTERS || [];
window.CHAPTERS.push({
    id: 'ch02',
    number: 2,
    title: 'Van Kampen\'s Theorem',
    subtitle: 'Computing π₁ via decomposition',
    sections: [
        {
            id: 'free-products',
            title: 'Free Products and Amalgamated Products',
            content: `
                <h2>Group Theory Review</h2>

                <p>Before proving Van Kampen's theorem, we review the necessary group-theoretic constructions. These operations allow us to build new groups from old ones in a controlled way.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 2.1 (Free Product)</div>
                    <div class="env-body">
                        <p>Let \\(G_1, G_2\\) be groups. The <strong>free product</strong> \\(G_1 * G_2\\) is the group of all finite "words" \\(g_1 h_1 g_2 h_2 \\cdots g_n h_n\\) where \\(g_i \\in G_1\\) and \\(h_i \\in G_2\\), subject only to the relations within each group.</p>
                        <p>More precisely, elements are reduced words (no consecutive elements from the same group, no identity elements), with concatenation as the group operation.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 2.2 (Free Product of Cyclic Groups)</div>
                    <div class="env-body">
                        <ul>
                            <li>\\(\\mathbb{Z} * \\mathbb{Z}\\) is the <strong>free group on two generators</strong> \\(F_2\\). Elements look like \\(a^3 b^{-2} a b^5\\), where \\(a, b\\) are the generators.</li>
                            <li>\\(\\mathbb{Z}/2 * \\mathbb{Z}/3\\) has elements like \\(aba\\) where \\(a^2 = 1\\) and \\(b^3 = 1\\), but \\(ab \\neq ba\\).</li>
                            <li>\\(G * \\{1\\} \\cong G\\) (free product with trivial group is just \\(G\\)).</li>
                        </ul>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 2.3 (Amalgamated Free Product)</div>
                    <div class="env-body">
                        <p>Let \\(G_1, G_2, H\\) be groups with homomorphisms \\(\\phi_i: H \\to G_i\\). The <strong>amalgamated free product</strong> (or <em>free product with amalgamation</em>) \\(G_1 *_H G_2\\) is the quotient of \\(G_1 * G_2\\) by the normal subgroup generated by all elements of the form \\(\\phi_1(h) \\phi_2(h)^{-1}\\) for \\(h \\in H\\).</p>
                        <p>Intuitively, we "glue" \\(G_1\\) and \\(G_2\\) along the common subgroup \\(H\\), identifying \\(\\phi_1(h)\\) with \\(\\phi_2(h)\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 2.4</div>
                    <div class="env-body">
                        <ul>
                            <li>\\(G_1 *_{\\{1\\}} G_2 = G_1 * G_2\\) (amalgamating over trivial group gives free product)</li>
                            <li>\\(\\mathbb{Z} *_{\\mathbb{Z}} \\mathbb{Z} \\cong \\mathbb{Z}\\) (amalgamating over the whole group collapses to a single copy)</li>
                            <li>\\(\\mathbb{Z} *_{2\\mathbb{Z}} \\mathbb{Z}\\) is more interesting—we glue two copies of \\(\\mathbb{Z}\\) along the even integers</li>
                        </ul>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="group-amalgamation"></div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Universal Property)</div>
                    <div class="env-body">
                        <p>Both constructions satisfy universal properties. For \\(G_1 * G_2\\): any two homomorphisms \\(f_i: G_i \\to K\\) extend uniquely to \\(f: G_1 * G_2 \\to K\\). For \\(G_1 *_H G_2\\): if \\(f_i: G_i \\to K\\) satisfy \\(f_1 \\circ \\phi_1 = f_2 \\circ \\phi_2\\), they extend uniquely to \\(G_1 *_H G_2\\).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'group-amalgamation',
                    title: 'Group Amalgamation Builder',
                    description: 'Visualize how groups are glued together',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 300;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let amalgType = 'free'; // 'free', 'amalgamated'

                        const btn1 = document.createElement('button');
                        btn1.textContent = 'Free Product G₁ * G₂';
                        btn1.onclick = () => { amalgType = 'free'; draw(); };
                        controls.appendChild(btn1);

                        const btn2 = document.createElement('button');
                        btn2.textContent = 'Amalgamated G₁ *_H G₂';
                        btn2.onclick = () => { amalgType = 'amalgamated'; draw(); };
                        controls.appendChild(btn2);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const cx = canvas.width / 2;
                            const cy = canvas.height / 2;

                            if (amalgType === 'free') {
                                // Two separate circles
                                ctx.strokeStyle = '#3fb950';
                                ctx.fillStyle = 'rgba(63, 185, 80, 0.1)';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc(cx - 80, cy, 60, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.stroke();

                                ctx.strokeStyle = '#58a6ff';
                                ctx.fillStyle = 'rgba(88, 166, 255, 0.1)';
                                ctx.beginPath();
                                ctx.arc(cx + 80, cy, 60, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.stroke();

                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '18px monospace';
                                ctx.fillText('G₁', cx - 90, cy);
                                ctx.fillText('G₂', cx + 70, cy);

                                ctx.fillStyle = '#8b949e';
                                ctx.font = '14px sans-serif';
                                ctx.fillText('No identification (disjoint union)', cx - 100, cy + 100);
                            } else {
                                // Two overlapping circles with common region
                                ctx.strokeStyle = '#3fb950';
                                ctx.fillStyle = 'rgba(63, 185, 80, 0.15)';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc(cx - 40, cy, 60, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.stroke();

                                ctx.strokeStyle = '#58a6ff';
                                ctx.fillStyle = 'rgba(88, 166, 255, 0.15)';
                                ctx.beginPath();
                                ctx.arc(cx + 40, cy, 60, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.stroke();

                                // Highlight intersection
                                ctx.fillStyle = 'rgba(240, 136, 62, 0.3)';
                                ctx.beginPath();
                                ctx.arc(cx - 40, cy, 60, -Math.asin(40/60), Math.asin(40/60));
                                ctx.arc(cx + 40, cy, 60, Math.PI - Math.asin(40/60), Math.PI + Math.asin(40/60), true);
                                ctx.closePath();
                                ctx.fill();

                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '18px monospace';
                                ctx.fillText('G₁', cx - 70, cy);
                                ctx.fillText('G₂', cx + 50, cy);
                                ctx.fillStyle = '#f0883e';
                                ctx.fillText('H', cx - 10, cy);

                                ctx.fillStyle = '#8b949e';
                                ctx.font = '14px sans-serif';
                                ctx.fillText('Identify φ₁(h) with φ₂(h) for all h ∈ H', cx - 120, cy + 100);
                            }
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that \\(\\mathbb{Z} * \\mathbb{Z} \\cong F_2\\), the free group on two generators.',
                    hint: 'Let \\(a, b\\) be the generators of the two copies of \\(\\mathbb{Z}\\). Every element of \\(\\mathbb{Z} * \\mathbb{Z}\\) is a finite word in \\(a, b\\) with no relations other than group axioms.',
                    solution: 'The generators \\(1 \\in \\mathbb{Z}\\) (first copy) and \\(1 \\in \\mathbb{Z}\\) (second copy) freely generate \\(\\mathbb{Z} * \\mathbb{Z}\\). By definition of free group, \\(F_2 = \\langle a, b \\mid \\text{no relations} \\rangle \\cong \\mathbb{Z} * \\mathbb{Z}\\).'
                },
                {
                    question: 'Prove that \\(G_1 *_G G_2 \\cong G\\) when \\(\\phi_1, \\phi_2: G \\to G_i\\) are the identity maps (i.e., \\(G_1 = G_2 = G\\)).',
                    hint: 'The amalgamation identifies every element of the first copy with the corresponding element of the second copy.',
                    solution: 'Since we identify \\(g \\in G_1\\) with \\(g \\in G_2\\) for all \\(g\\), there is no distinction between the two copies. The quotient collapses to a single copy of \\(G\\).'
                },
                {
                    question: 'What is \\(\\mathbb{Z}/2 * \\mathbb{Z}/3\\)? Is it finite?',
                    hint: 'Consider words like \\(aba\\). Can these be reduced?',
                    solution: 'Elements are reduced words in generators \\(a\\) (order 2) and \\(b\\) (order 3), such as \\(aba, bab, abab, \\ldots\\). Since there are no relations between \\(a\\) and \\(b\\), the group is infinite. In fact, \\(\\mathbb{Z}/2 * \\mathbb{Z}/3\\) is the modular group \\(PSL(2, \\mathbb{Z})\\) up to finite index.'
                },
                {
                    question: 'Let \\(H = \\langle a \\rangle \\cong \\mathbb{Z}\\), \\(G_1 = \\langle a, b \\mid [a,b] = 1 \\rangle \\cong \\mathbb{Z}^2\\), \\(G_2 = \\langle a, c \\mid [a,c] = 1 \\rangle \\cong \\mathbb{Z}^2\\) with \\(\\phi_i\\) including \\(\\langle a \\rangle\\) in \\(G_i\\). Describe \\(G_1 *_H G_2\\).',
                    hint: 'We are gluing two planes along a common line.',
                    solution: 'The amalgamated product is \\(\\langle a, b, c \\mid [a,b] = [a,c] = 1 \\rangle\\). This is \\(\\mathbb{Z}^2 * \\mathbb{Z} \\cong \\mathbb{Z}^3\\) (the group is abelian since \\(a\\) commutes with both \\(b\\) and \\(c\\), and there are no other relations).'
                },
                {
                    question: 'Show that the free product is associative: \\((G_1 * G_2) * G_3 \\cong G_1 * (G_2 * G_3)\\).',
                    hint: 'Both sides are words in elements from \\(G_1, G_2, G_3\\) with no additional relations.',
                    solution: 'By the universal property of free product, both \\((G_1 * G_2) * G_3\\) and \\(G_1 * (G_2 * G_3)\\) satisfy the same universal property for three groups. Thus they are canonically isomorphic.'
                }
            ]
        },

        {
            id: 'van-kampen-theorem',
            title: 'Van Kampen\'s Theorem',
            content: `
                <h2>The Fundamental Theorem of Path-Connected Decompositions</h2>

                <p>Van Kampen's theorem allows us to compute \\(\\pi_1(X)\\) by decomposing \\(X\\) into simpler pieces whose fundamental groups we already know. It is one of the most powerful computational tools in algebraic topology.</p>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 2.5 (Van Kampen's Theorem)</div>
                    <div class="env-body">
                        <p>Let \\(X = U_1 \\cup U_2\\) where \\(U_1, U_2\\) are open and path-connected. Assume \\(U_0 = U_1 \\cap U_2\\) is non-empty and path-connected, and contains the basepoint \\(x_0\\).</p>
                        <p>Let \\(\\iota_k: U_0 \\hookrightarrow U_k\\) and \\(j_k: U_k \\hookrightarrow X\\) be the inclusions. Then the diagram
                        \\[\\begin{array}{ccc}
                        \\pi_1(U_0, x_0) & \\xrightarrow{(\\iota_1)_*, (\\iota_2)_*} & \\pi_1(U_1, x_0) \\times \\pi_1(U_2, x_0) \\\\
                        & & \\downarrow (j_1)_* - (j_2)_* \\\\
                        & & \\pi_1(X, x_0)
                        \\end{array}\\]
                        induces an isomorphism
                        \\[\\pi_1(X, x_0) \\cong \\pi_1(U_1, x_0) *_{\\pi_1(U_0, x_0)} \\pi_1(U_2, x_0).\\]
                        </p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof Sketch</div>
                    <div class="env-body">
                        <p><strong>Surjectivity:</strong> Any loop \\(\\gamma\\) in \\(X\\) can be subdivided into segments lying entirely in \\(U_1\\) or \\(U_2\\) (by compactness of \\([0,1]\\)). This shows every element of \\(\\pi_1(X)\\) is a product of loops from \\(\\pi_1(U_1)\\) and \\(\\pi_1(U_2)\\).</p>
                        <p><strong>Relations:</strong> If a loop is in both \\(U_1\\) and \\(U_2\\), it lies in \\(U_0\\), so we must identify \\((\\iota_1)_*([\\gamma])\\) with \\((\\iota_2)_*([\\gamma])\\). These are exactly the relations in the amalgamated product.</p>
                        <p><strong>Injectivity:</strong> If a word in \\(\\pi_1(U_1) *_{\\pi_1(U_0)} \\pi_1(U_2)\\) represents the trivial element of \\(\\pi_1(X)\\), we show it was already trivial in the amalgamated product (uses Seifert-van Kampen's normal form theorem). See Hatcher, §1.2 for full details.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="decomposition-visualizer"></div>

                <div class="env-block corollary">
                    <div class="env-title">Corollary 2.6 (Van Kampen for Free Products)</div>
                    <div class="env-body">
                        <p>If \\(U_0 = U_1 \\cap U_2\\) is simply connected (\\(\\pi_1(U_0) = 0\\)), then
                        \\[\\pi_1(X, x_0) \\cong \\pi_1(U_1, x_0) * \\pi_1(U_2, x_0).\\]
                        </p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Generalization)</div>
                    <div class="env-body">
                        <p>Van Kampen's theorem generalizes to arbitrary (not just two) open covers: if \\(X = \\bigcup_{i \\in I} U_i\\) with appropriate path-connectedness conditions, then \\(\\pi_1(X)\\) is the colimit of the \\(\\pi_1(U_i)\\) over the diagram of inclusions.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'decomposition-visualizer',
                    title: 'Space Decomposition Visualizer',
                    description: 'See how X = U₁ ∪ U₂ decomposes',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 350;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let showU1 = true, showU2 = true;

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.textContent = 'Toggle U₁ and U₂ to see the decomposition';
                        body.appendChild(info);

                        const toggleU1 = document.createElement('button');
                        toggleU1.textContent = 'Toggle U₁';
                        toggleU1.onclick = () => { showU1 = !showU1; draw(); };
                        controls.appendChild(toggleU1);

                        const toggleU2 = document.createElement('button');
                        toggleU2.textContent = 'Toggle U₂';
                        toggleU2.onclick = () => { showU2 = !showU2; draw(); };
                        controls.appendChild(toggleU2);

                        const showBoth = document.createElement('button');
                        showBoth.textContent = 'Show Both';
                        showBoth.onclick = () => { showU1 = true; showU2 = true; draw(); };
                        controls.appendChild(showBoth);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const cx = canvas.width / 2;
                            const cy = canvas.height / 2;

                            // Draw figure-8 shape
                            const r = 60;
                            const offset = 65;

                            // U₁ (left circle)
                            if (showU1) {
                                ctx.fillStyle = 'rgba(63, 185, 80, 0.3)';
                                ctx.strokeStyle = '#3fb950';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc(cx - offset, cy, r, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.stroke();
                                ctx.fillStyle = '#3fb950';
                                ctx.font = '18px monospace';
                                ctx.fillText('U₁', cx - offset - 10, cy - r - 10);
                            }

                            // U₂ (right circle)
                            if (showU2) {
                                ctx.fillStyle = 'rgba(88, 166, 255, 0.3)';
                                ctx.strokeStyle = '#58a6ff';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc(cx + offset, cy, r, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.stroke();
                                ctx.fillStyle = '#58a6ff';
                                ctx.font = '18px monospace';
                                ctx.fillText('U₂', cx + offset - 10, cy - r - 10);
                            }

                            // Basepoint (intersection)
                            ctx.fillStyle = '#f0883e';
                            ctx.beginPath();
                            ctx.arc(cx, cy, 8, 0, 2*Math.PI);
                            ctx.fill();
                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '14px monospace';
                            ctx.fillText('x₀ ∈ U₀ = U₁ ∩ U₂', cx - 70, cy + 30);

                            // Labels
                            ctx.fillStyle = '#8b949e';
                            ctx.font = '14px sans-serif';
                            if (showU1 && showU2) {
                                ctx.fillText('X = U₁ ∪ U₂ (figure-eight)', cx - 90, canvas.height - 20);
                            } else if (showU1) {
                                ctx.fillText('U₁ only (left circle)', cx - 70, canvas.height - 20);
                            } else if (showU2) {
                                ctx.fillText('U₂ only (right circle)', cx - 70, canvas.height - 20);
                            }
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'State Van Kampen\'s theorem in the case where \\(U_0\\) is simply connected.',
                    hint: 'When \\(\\pi_1(U_0) = 0\\), the amalgamated product reduces to a free product.',
                    solution: 'If \\(\\pi_1(U_0, x_0) = 0\\), then \\(\\pi_1(X, x_0) \\cong \\pi_1(U_1, x_0) * \\pi_1(U_2, x_0)\\) (free product).'
                }
            ]
        },

        {
            id: 'applications',
            title: 'Applications of Van Kampen\'s Theorem',
            content: `
                <h2>Computing Fundamental Groups</h2>

                <div class="env-block example">
                    <div class="env-title">Example 2.7 (Figure-Eight: S¹ ∨ S¹)</div>
                    <div class="env-body">
                        <p>Let \\(X = S^1 \\vee S^1\\) (wedge sum of two circles). Decompose \\(X = U_1 \\cup U_2\\) where:</p>
                        <ul>
                            <li>\\(U_1\\) = left circle with a small neighborhood of the basepoint removed from the right side</li>
                            <li>\\(U_2\\) = right circle with a small neighborhood of the basepoint removed from the left side</li>
                            <li>\\(U_0 = U_1 \\cap U_2\\) is a small contractible neighborhood of the basepoint</li>
                        </ul>
                        <p>Since \\(U_1 \\simeq S^1\\), \\(U_2 \\simeq S^1\\), and \\(U_0\\) is contractible, Van Kampen gives:
                        \\[\\pi_1(S^1 \\vee S^1, x_0) \\cong \\mathbb{Z} * \\mathbb{Z} = F_2,\\]
                        the free group on two generators!</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 2.8 (Wedge of n Circles)</div>
                    <div class="env-body">
                        <p>By induction, \\(\\pi_1\\left(\\bigvee_{i=1}^n S^1\\right) \\cong F_n\\), the free group on \\(n\\) generators. This space is called a <strong>bouquet of circles</strong> or <strong>rose with n petals</strong>.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 2.9 (Torus T²)</div>
                    <div class="env-body">
                        <p>The torus \\(T^2 = S^1 \\times S^1\\) can be decomposed as \\(X = U_1 \\cup U_2\\) where \\(U_1, U_2\\) are neighborhoods of the two "circles" generating \\(T^2\\), each homotopy equivalent to \\(S^1\\), and \\(U_0\\) is an annulus homotopy equivalent to \\(S^1\\).</p>
                        <p>We get \\(\\pi_1(T^2) \\cong \\mathbb{Z} *_{\\mathbb{Z}} \\mathbb{Z}\\). The gluing map \\(\\mathbb{Z} \\to \\mathbb{Z} \\times \\mathbb{Z}\\) sends \\(1 \\mapsto (1, 1)\\) (the "meridian" winds once around each factor). But there is an easier approach: we already know \\(\\pi_1(S^1 \\times S^1) \\cong \\pi_1(S^1) \\times \\pi_1(S^1) \\cong \\mathbb{Z} \\times \\mathbb{Z}\\) from the product formula (which we will prove later).</p>
                        <p>Alternatively, decompose \\(T^2\\) as \\([0,1]^2\\) with opposite edges identified. Use a decomposition into two contractible pieces meeting in a figure-eight, giving \\(\\pi_1(T^2) \\cong \\mathbb{Z} * \\mathbb{Z} / N\\) where \\(N\\) is generated by the commutator \\([a, b]\\). Thus \\(\\pi_1(T^2) \\cong \\langle a, b \\mid aba^{-1}b^{-1} = 1 \\rangle \\cong \\mathbb{Z}^2\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="surface-pi1"></div>

                <div class="env-block example">
                    <div class="env-title">Example 2.10 (Klein Bottle K)</div>
                    <div class="env-body">
                        <p>The Klein bottle \\(K\\) is obtained from a square with edge identifications \\((0, y) \\sim (1, y)\\) and \\((x, 0) \\sim (1-x, 1)\\) (one edge is twisted).</p>
                        <p>Using a similar decomposition, we find
                        \\[\\pi_1(K) \\cong \\langle a, b \\mid aba^{-1}b = 1 \\rangle.\\]
                        This is a <em>non-abelian</em> group (unlike the torus). Rewriting: \\(aba^{-1} = b^{-1}\\), so \\(b\\) has "opposite" conjugates under \\(a\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 2.11 (CW Complexes)</div>
                    <div class="env-body">
                        <p>Van Kampen's theorem is particularly powerful for <strong>CW complexes</strong>. If \\(X\\) is obtained by attaching 2-cells to a 1-dimensional skeleton \\(X^{(1)}\\), then:
                        \\[\\pi_1(X) \\cong \\pi_1(X^{(1)}) / N\\]
                        where \\(N\\) is the normal subgroup generated by the attaching maps of the 2-cells.</p>
                        <p>Since \\(X^{(1)}\\) is a graph, \\(\\pi_1(X^{(1)}) \\cong F_n\\) where \\(n = \\text{edges} - \\text{vertices} + 1\\). This gives a <strong>presentation</strong> of \\(\\pi_1(X)\\) with generators (edges) and relations (2-cells).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'surface-pi1',
                    title: 'Surface π₁ Computer',
                    description: 'Compute fundamental groups of surfaces',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 300;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let surfaceType = 'torus';

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.innerHTML = 'Torus T²: π₁ = ⟨a, b | aba⁻¹b⁻¹ = 1⟩ ≅ ℤ²';
                        body.appendChild(info);

                        const btn1 = document.createElement('button');
                        btn1.textContent = 'Torus';
                        btn1.onclick = () => {
                            surfaceType = 'torus';
                            info.innerHTML = 'Torus T²: π₁ = ⟨a, b | aba⁻¹b⁻¹ = 1⟩ ≅ ℤ²';
                            draw();
                        };
                        controls.appendChild(btn1);

                        const btn2 = document.createElement('button');
                        btn2.textContent = 'Klein Bottle';
                        btn2.onclick = () => {
                            surfaceType = 'klein';
                            info.innerHTML = 'Klein bottle K: π₁ = ⟨a, b | aba⁻¹b = 1⟩ (non-abelian)';
                            draw();
                        };
                        controls.appendChild(btn2);

                        const btn3 = document.createElement('button');
                        btn3.textContent = 'RP²';
                        btn3.onclick = () => {
                            surfaceType = 'rp2';
                            info.innerHTML = 'Projective plane ℝP²: π₁ = ℤ/2ℤ';
                            draw();
                        };
                        controls.appendChild(btn3);

                        const btn4 = document.createElement('button');
                        btn4.textContent = 'Figure-8';
                        btn4.onclick = () => {
                            surfaceType = 'figure8';
                            info.innerHTML = 'Figure-eight S¹ ∨ S¹: π₁ = ℤ * ℤ = F₂ (free group on 2 generators)';
                            draw();
                        };
                        controls.appendChild(btn4);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const cx = canvas.width / 2;
                            const cy = canvas.height / 2;

                            if (surfaceType === 'torus') {
                                // Draw torus as two loops
                                ctx.strokeStyle = '#3fb950';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.ellipse(cx, cy, 80, 50, 0, 0, 2*Math.PI);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.ellipse(cx, cy, 50, 80, 0, 0, 2*Math.PI);
                                ctx.stroke();
                            } else if (surfaceType === 'klein') {
                                // Klein bottle (twisted)
                                ctx.strokeStyle = '#f0883e';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.ellipse(cx, cy, 80, 50, 0, 0, 2*Math.PI);
                                ctx.stroke();
                                ctx.strokeStyle = '#d29922';
                                ctx.beginPath();
                                ctx.ellipse(cx, cy, 50, 80, Math.PI/4, 0, 2*Math.PI);
                                ctx.stroke();
                            } else if (surfaceType === 'rp2') {
                                // RP² as hemisphere with antipodal boundary
                                ctx.strokeStyle = '#bc8cff';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc(cx, cy, 70, 0, Math.PI);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.ellipse(cx, cy, 70, 20, 0, 0, 2*Math.PI);
                                ctx.stroke();
                            } else {
                                // Figure-8
                                ctx.strokeStyle = '#58a6ff';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.arc(cx - 50, cy, 40, 0, 2*Math.PI);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.arc(cx + 50, cy, 40, 0, 2*Math.PI);
                                ctx.stroke();
                                ctx.fillStyle = '#f0883e';
                                ctx.beginPath();
                                ctx.arc(cx, cy, 6, 0, 2*Math.PI);
                                ctx.fill();
                            }
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Compute \\(\\pi_1(S^1 \\vee S^1, x_0)\\) using Van Kampen\'s theorem.',
                    hint: 'Decompose the figure-eight into two open sets, each homotopy equivalent to \\(S^1\\), meeting in a contractible neighborhood of the basepoint.',
                    solution: 'Let \\(U_1\\) and \\(U_2\\) be neighborhoods of the left and right circles, each deformation retracting to \\(S^1\\). Their intersection \\(U_0\\) is a small disk around the basepoint, which is contractible. By Van Kampen, \\(\\pi_1(S^1 \\vee S^1) \\cong \\pi_1(U_1) * \\pi_1(U_2) \\cong \\mathbb{Z} * \\mathbb{Z} = F_2\\).'
                },
                {
                    question: 'Show that \\(\\pi_1(T^2) \\cong \\mathbb{Z} \\times \\mathbb{Z}\\) by representing \\(T^2\\) as a square with opposite edges identified.',
                    hint: 'Decompose the square into two rectangles meeting along a vertical line. Each rectangle deformation retracts to a circle.',
                    solution: 'Let \\(U_1\\) be the left half and \\(U_2\\) the right half. Both deformation retract to vertical circles, so \\(\\pi_1(U_i) \\cong \\mathbb{Z}\\). The intersection \\(U_0\\) is a vertical line segment (contractible). Van Kampen gives \\(\\pi_1(T^2) \\cong \\mathbb{Z} *_0 \\mathbb{Z} = \\mathbb{Z} * \\mathbb{Z}\\). But wait—we need to account for the edge identifications! The correct decomposition uses a square minus a small disk, giving \\(\\pi_1(T^2) \\cong \\langle a, b \\mid [a, b] = 1 \\rangle \\cong \\mathbb{Z}^2\\). See Hatcher, Example 1.24.'
                },
                {
                    question: 'Prove that \\(\\pi_1(\\mathbb{R}P^2) \\cong \\mathbb{Z}/2\\mathbb{Z}\\).',
                    hint: 'Represent \\(\\mathbb{R}P^2\\) as a disk with antipodal boundary points identified. Decompose into two disks meeting along a diameter.',
                    solution: 'Let \\(U_1, U_2\\) be the upper and lower hemispheres (both contractible), meeting along the equator \\(U_0 \\simeq S^1\\). Van Kampen gives \\(\\pi_1(\\mathbb{R}P^2) \\cong 0 *_{\\mathbb{Z}} 0\\). But the inclusion \\(\\mathbb{Z} = \\pi_1(S^1) \\to \\pi_1(U_i) = 0\\) factors through the quotient, giving the relation that a generator \\(a\\) of \\(\\mathbb{Z}\\) gets identified with its double \\(2a\\). This yields \\(\\pi_1(\\mathbb{R}P^2) \\cong \\mathbb{Z}/2\\mathbb{Z}\\). Alternatively, use the covering map \\(S^2 \\to \\mathbb{R}P^2\\).'
                }
            ]
        },

        {
            id: 'examples',
            title: 'More Examples: Torus, Klein Bottle, Figure-8',
            content: `
                <h2>Detailed Computations</h2>

                <div class="env-block example">
                    <div class="env-title">Example 2.12 (Torus via CW Complex)</div>
                    <div class="env-body">
                        <p>Build \\(T^2\\) as a CW complex:</p>
                        <ul>
                            <li>One 0-cell: \\(x_0\\)</li>
                            <li>Two 1-cells: \\(a, b\\) (loops around the two "holes")</li>
                            <li>One 2-cell attached via the loop \\(aba^{-1}b^{-1}\\) (the boundary of the square)</li>
                        </ul>
                        <p>The 1-skeleton is \\(S^1 \\vee S^1\\), so \\(\\pi_1(T^{(1)}) \\cong F_2 = \\langle a, b \\rangle\\). Attaching the 2-cell imposes the relation \\([a, b] = 1\\). Thus:
                        \\[\\pi_1(T^2) \\cong \\langle a, b \\mid aba^{-1}b^{-1} = 1 \\rangle \\cong \\mathbb{Z} \\times \\mathbb{Z}.\\]
                        </p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 2.13 (Klein Bottle Presentation)</div>
                    <div class="env-body">
                        <p>Similarly, build \\(K\\) from one 0-cell, two 1-cells \\(a, b\\), and one 2-cell attached via \\(aba^{-1}b\\) (twisted gluing). We get:
                        \\[\\pi_1(K) \\cong \\langle a, b \\mid aba^{-1}b = 1 \\rangle.\\]
                        Rewriting: \\(aba^{-1} = b^{-1}\\), so \\(a\\) acts on \\(b\\) by inversion. This group is non-abelian and is a semidirect product \\(\\mathbb{Z} \\rtimes \\mathbb{Z}\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 2.14 (Universal Cover of Figure-8)</div>
                    <div class="env-body">
                        <p>The universal cover of \\(S^1 \\vee S^1\\) is an <strong>infinite 4-valent tree</strong> (also called the <em>Cayley graph of \\(F_2\\)</em>). Each vertex has degree 4, corresponding to four edges labeled \\(a, a^{-1}, b, b^{-1}\\).</p>
                        <p>The covering map \\(p: \\tilde{X} \\to S^1 \\vee S^1\\) wraps the tree onto the figure-eight. Each edge of the tree maps to the corresponding loop in \\(S^1 \\vee S^1\\).</p>
                        <p>Since \\(\\tilde{X}\\) is contractible (it's a tree), we have \\(\\pi_1(\\tilde{X}) = 0\\). The deck transformations are isomorphic to \\(\\pi_1(S^1 \\vee S^1) = F_2\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="universal-cover-tree"></div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Surfaces of Genus g)</div>
                    <div class="env-body">
                        <p>A <strong>closed orientable surface of genus \\(g\\)</strong> (sphere with \\(g\\) handles) has fundamental group
                        \\[\\pi_1(\\Sigma_g) \\cong \\langle a_1, b_1, \\ldots, a_g, b_g \\mid [a_1, b_1] \\cdots [a_g, b_g] = 1 \\rangle.\\]
                        For \\(g = 1\\) (torus), this gives \\(\\mathbb{Z}^2\\). For \\(g \\ge 2\\), this is a <em>non-abelian</em> group.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'universal-cover-tree',
                    title: 'Universal Cover of Figure-8',
                    description: 'Explore the infinite 4-valent tree covering S¹ ∨ S¹',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let depth = 3;

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.textContent = `Showing ${depth} levels of the tree`;
                        body.appendChild(info);

                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = 1;
                        slider.max = 5;
                        slider.value = depth;
                        slider.style.width = '300px';
                        slider.oninput = (e) => {
                            depth = parseInt(e.target.value);
                            info.textContent = `Showing ${depth} levels of the tree`;
                            draw();
                        };
                        controls.appendChild(slider);

                        function drawTree(x, y, angle, length, level) {
                            if (level === 0) return;

                            const x2 = x + length * Math.cos(angle);
                            const y2 = y + length * Math.sin(angle);

                            ctx.strokeStyle = '#58a6ff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();

                            ctx.fillStyle = '#3fb950';
                            ctx.beginPath();
                            ctx.arc(x2, y2, 4, 0, 2*Math.PI);
                            ctx.fill();

                            const newLength = length * 0.7;
                            const angleStep = Math.PI / 3;

                            // Draw 3 branches (we came from one direction, go to 3 others for 4-valent)
                            for (let i = -1; i <= 1; i++) {
                                if (i === 0 && level < depth) continue; // Don't go back
                                const newAngle = angle + i * angleStep;
                                drawTree(x2, y2, newAngle, newLength, level - 1);
                            }
                        }

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const cx = canvas.width / 2;
                            const cy = canvas.height - 50;

                            // Draw root
                            ctx.fillStyle = '#f0883e';
                            ctx.beginPath();
                            ctx.arc(cx, cy, 6, 0, 2*Math.PI);
                            ctx.fill();

                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '12px monospace';
                            ctx.fillText('basepoint', cx - 30, cy + 20);

                            // Draw tree (4-valent means 4 edges from root, but we show 3 directions)
                            const startAngles = [-Math.PI/2, -Math.PI/2 - Math.PI/3, -Math.PI/2 + Math.PI/3];
                            startAngles.forEach(angle => {
                                drawTree(cx, cy, angle, 50, depth);
                            });

                            ctx.fillStyle = '#8b949e';
                            ctx.font = '14px sans-serif';
                            ctx.fillText('Each vertex has degree 4 (edges labeled a, a⁻¹, b, b⁻¹)', 20, 20);
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that the fundamental group of a genus-\\(g\\) surface is \\[\\pi_1(\\Sigma_g) \\cong \\langle a_1, b_1, \\ldots, a_g, b_g \\mid [a_1, b_1] \\cdots [a_g, b_g] = 1 \\rangle.\\]',
                    hint: 'Build \\(\\Sigma_g\\) as a \\(4g\\)-gon with edges identified in the pattern \\(a_1 b_1 a_1^{-1} b_1^{-1} \\cdots a_g b_g a_g^{-1} b_g^{-1}\\). Use CW complex structure.',
                    solution: 'The \\(4g\\)-gon with one vertex, \\(2g\\) edges (identified in pairs), and one 2-cell gives the CW structure. The 1-skeleton is a wedge of \\(2g\\) circles, so \\(\\pi_1(\\Sigma_g^{(1)}) \\cong F_{2g}\\). The 2-cell is attached via the boundary word \\([a_1, b_1] \\cdots [a_g, b_g]\\), giving the stated presentation.'
                },
                {
                    question: 'Verify that \\(\\pi_1(K) \\cong \\langle a, b \\mid aba^{-1}b = 1 \\rangle\\) is non-abelian.',
                    hint: 'Show that \\([a, b] \\neq 1\\) in this group.',
                    solution: 'The relation \\(aba^{-1}b = 1\\) gives \\(aba^{-1} = b^{-1}\\), so \\(ab = b^{-1}a\\). Then \\([a, b] = aba^{-1}b^{-1} = b^{-1}b^{-1} = b^{-2} \\neq 1\\) (since \\(b\\) has infinite order). Thus the group is non-abelian.'
                },
                {
                    question: 'Describe the deck transformations of the covering \\(\\tilde{X} \\to S^1 \\vee S^1\\) where \\(\\tilde{X}\\) is the 4-valent tree.',
                    hint: 'Each element of \\(\\pi_1(S^1 \\vee S^1) = F_2\\) acts as a graph automorphism of \\(\\tilde{X}\\).',
                    solution: 'The deck transformation group is \\(\\pi_1(S^1 \\vee S^1) / \\pi_1(\\tilde{X}) = F_2 / \\{1\\} \\cong F_2\\). Each generator \\(a, b \\in F_2\\) acts by shifting the tree along the edge labeled \\(a\\) or \\(b\\). The tree is the Cayley graph of \\(F_2\\), and deck transformations are left multiplication.'
                },
                {
                    question: 'Compute \\(\\pi_1(S^2 \\setminus \\{p_1, \\ldots, p_n\\})\\) (sphere with \\(n\\) points removed).',
                    hint: 'Deformation retract to a wedge of circles.',
                    solution: 'The space \\(S^2 \\setminus \\{p_1, \\ldots, p_n\\}\\) deformation retracts onto a wedge of \\(n-1\\) circles. Thus \\(\\pi_1(S^2 \\setminus \\{p_1, \\ldots, p_n\\}) \\cong F_{n-1}\\), the free group on \\(n-1\\) generators.'
                },
                {
                    question: 'Show that \\(\\pi_1(\\mathbb{R}^3 \\setminus K) \\cong \\mathbb{Z}\\) where \\(K\\) is a knot (embedded circle in \\(\\mathbb{R}^3\\)).',
                    hint: 'The complement deformation retracts onto a torus surrounding the knot.',
                    solution: 'This is a deep result. For the <em>unknot</em> (standard circle), \\(\\mathbb{R}^3 \\setminus K\\) deformation retracts to a torus, so \\(\\pi_1 \\cong \\mathbb{Z}\\). For general knots, the fundamental group is more complicated (the <strong>knot group</strong>), but it is always infinite and has abelianization \\(\\mathbb{Z}\\).'
                }
            ]
        }
    ]
});
