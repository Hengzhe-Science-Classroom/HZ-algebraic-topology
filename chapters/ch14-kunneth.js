window.CHAPTERS.push({
  id: 'kunneth-formula',
  number: 14,
  title: 'Künneth Formula',
  subtitle: 'Homology and Cohomology of Product Spaces',
  sections: [
    // ============================================================
    // Section 1: Tensor Product of Chain Complexes
    // ============================================================
    {
      id: 'tensor-product-chain-complexes',
      title: 'Tensor Product of Chain Complexes',
      content: `
        <div class="env-block intuition">
          <p><strong>The Driving Question:</strong> Given spaces \\(X\\) and \\(Y\\) whose homology we know, can we compute \\(H_*(X \\times Y)\\)? Naively we might guess \\(H_n(X \\times Y) \\cong \\bigoplus_{p+q=n} H_p(X) \\otimes H_q(Y)\\). This is close, but not quite right when torsion is present. The <em>Künneth formula</em> provides the precise answer, involving a correction term from the <em>Tor</em> functor.</p>
        </div>

        <div class="env-block definition">
          <p><strong>Definition (Tensor Product of Abelian Groups):</strong> For abelian groups \\(A\\) and \\(B\\), the <em>tensor product</em> \\(A \\otimes_{\\mathbb{Z}} B\\) is the abelian group generated by symbols \\(a \\otimes b\\) (for \\(a \\in A\\), \\(b \\in B\\)) subject to bilinearity:</p>
          \\[
          (a_1 + a_2) \\otimes b = a_1 \\otimes b + a_2 \\otimes b, \\qquad a \\otimes (b_1 + b_2) = a \\otimes b_1 + a \\otimes b_2
          \\]
          <p><strong>Key computations:</strong></p>
          <ul>
            <li>\\(\\mathbb{Z} \\otimes A \\cong A\\) for any \\(A\\).</li>
            <li>\\(\\mathbb{Z}/m \\otimes \\mathbb{Z}/n \\cong \\mathbb{Z}/\\gcd(m,n)\\).</li>
            <li>\\(\\mathbb{Z}/n \\otimes \\mathbb{Q} = 0\\) (torsion tensored with a divisible group vanishes).</li>
            <li>\\(\\mathbb{Z}^r \\otimes \\mathbb{Z}^s \\cong \\mathbb{Z}^{rs}\\).</li>
          </ul>
        </div>

        <div class="env-block definition">
          <p><strong>Definition (Tensor Product of Chain Complexes):</strong> Let \\((C_*, \\partial^C)\\) and \\((D_*, \\partial^D)\\) be chain complexes of \\(R\\)-modules. Their <em>tensor product</em> is the chain complex \\((C_* \\otimes D_*)\\) with</p>
          \\[
          (C \\otimes D)_n = \\bigoplus_{p+q=n} C_p \\otimes_R D_q
          \\]
          <p>and differential</p>
          \\[
          \\partial(c \\otimes d) = (\\partial^C c) \\otimes d + (-1)^{|c|} c \\otimes (\\partial^D d)
          \\]
          <p>where \\(|c| = p\\) is the degree of \\(c \\in C_p\\). The sign \\((-1)^{|c|}\\) is the <strong>Koszul sign rule</strong>.</p>
        </div>

        <div class="env-block theorem">
          <p><strong>Proposition (\\(\\partial^2 = 0\\)):</strong> With the Koszul sign convention, \\(\\partial^2 = 0\\) on \\(C_* \\otimes D_*\\).</p>
        </div>

        <div class="env-block proof">
          <p><strong>Proof:</strong> For \\(c \\in C_p\\), \\(d \\in D_q\\):</p>
          \\[
          \\partial^2(c \\otimes d) = \\partial\\bigl[(\\partial^C c) \\otimes d + (-1)^p c \\otimes (\\partial^D d)\\bigr]
          \\]
          \\[
          = \\underbrace{(\\partial^C)^2 c \\otimes d}_{=0} + (-1)^{p-1}(\\partial^C c) \\otimes (\\partial^D d) + (-1)^p (\\partial^C c) \\otimes (\\partial^D d) + (-1)^p(-1)^p \\underbrace{c \\otimes (\\partial^D)^2 d}_{=0}
          \\]
          <p>The two middle terms cancel: \\((-1)^{p-1} + (-1)^p = 0\\). This is precisely why the Koszul sign is needed. \\(\\square\\)</p>
        </div>

        <div class="env-block theorem">
          <p><strong>Eilenberg-Zilber Theorem:</strong> For topological spaces \\(X\\) and \\(Y\\), there are natural chain homotopy equivalences</p>
          \\[
          C_*(X \\times Y) \\simeq C_*(X) \\otimes C_*(Y)
          \\]
          <p>given by the <em>Alexander-Whitney map</em> \\(AW: C_*(X \\times Y) \\to C_*(X) \\otimes C_*(Y)\\) and the <em>Eilenberg-Zilber shuffle map</em> \\(EZ: C_*(X) \\otimes C_*(Y) \\to C_*(X \\times Y)\\), with \\(AW \\circ EZ \\simeq \\text{id}\\) and \\(EZ \\circ AW \\simeq \\text{id}\\).</p>
        </div>

        <div class="env-block remark">
          <p><strong>Remark (Alexander-Whitney Map):</strong> For a singular \\(n\\)-simplex \\(\\sigma: \\Delta^n \\to X \\times Y\\), writing \\(\\sigma = (\\sigma_X, \\sigma_Y)\\), the AW map is:</p>
          \\[
          AW(\\sigma) = \\sum_{p+q=n} \\sigma_X|_{[v_0, \\ldots, v_p]} \\otimes \\sigma_Y|_{[v_p, \\ldots, v_n]}
          \\]
          <p>This is the same "front face / back face" decomposition that gives the cup product. Acyclic model theory shows AW and EZ are chain homotopy inverse. The Eilenberg-Zilber theorem reduces computing \\(H_*(X \\times Y)\\) to a purely algebraic problem.</p>
        </div>

        <div class="env-block example">
          <p><strong>Example (Interval \\(\\times\\) Interval):</strong> Consider \\(I \\times I\\) where \\(I = [0,1]\\). The singular chain complex \\(C_*(I)\\) has \\(C_0(I) = \\mathbb{Z}\\langle [0], [1]\\rangle\\) and \\(C_1(I) = \\mathbb{Z}\\langle e\\rangle\\) with \\(\\partial e = [1] - [0]\\).</p>
          <ul>
            <li>\\((C_*(I) \\otimes C_*(I))_0 = C_0 \\otimes C_0 = \\mathbb{Z}^4\\), generated by \\([i] \\otimes [j]\\) for \\(i,j \\in \\{0,1\\}\\).</li>
            <li>\\((C_*(I) \\otimes C_*(I))_1 = (C_1 \\otimes C_0) \\oplus (C_0 \\otimes C_1) = \\mathbb{Z}^4\\).</li>
            <li>\\((C_*(I) \\otimes C_*(I))_2 = C_1 \\otimes C_1 = \\mathbb{Z}\\langle e \\otimes e \\rangle\\), with \\(\\partial(e \\otimes e) = (\\partial e) \\otimes e + (-1)^1 e \\otimes (\\partial e) = ([1]-[0]) \\otimes e - e \\otimes ([1]-[0])\\).</li>
          </ul>
          <p>The chain complex of the tensor product correctly computes \\(H_*(I \\times I) = H_*(*) = \\mathbb{Z}\\) concentrated in degree 0, since \\(I \\times I\\) is contractible.</p>
        </div>
      `,
      visualizations: [
        {
          id: 'product-space-builder',
          title: 'Product Space Cell Structure',
          description: 'Visualize how cells of X and Y combine to form cells of X x Y',
          canvas: {
            setup: (viz) => {
              viz.state = {
                spaceX: 'S1',
                spaceY: 'S1',
                animPhase: 0,
                showLabels: true,
                highlightDeg: -1
              };
            },
            draw: (viz, ctx, width, height) => {
              ctx.clearRect(0, 0, width, height);
              viz.state.animPhase += 0.012;
              const t = viz.state.animPhase;

              ctx.fillStyle = '#2c3e50';
              ctx.font = 'bold 18px serif';
              ctx.textAlign = 'left';

              const spX = viz.state.spaceX;
              const spY = viz.state.spaceY;

              const cellData = {
                'S1': { name: 'S\u00B9', cells: [{dim: 0, label: 'e\u2070', count: 1}, {dim: 1, label: 'e\u00B9', count: 1}] },
                'S2': { name: 'S\u00B2', cells: [{dim: 0, label: 'e\u2070', count: 1}, {dim: 2, label: 'e\u00B2', count: 1}] },
                'T2': { name: 'T\u00B2', cells: [{dim: 0, label: 'e\u2070', count: 1}, {dim: 1, label: 'e\u00B9', count: 2}, {dim: 2, label: 'e\u00B2', count: 1}] },
                'I': { name: 'I', cells: [{dim: 0, label: 'e\u2070', count: 2}, {dim: 1, label: 'e\u00B9', count: 1}] }
              };

              const dX = cellData[spX];
              const dY = cellData[spY];

              ctx.fillText(dX.name + ' \u00D7 ' + dY.name + ': Cell Structure', 20, 30);

              const productCells = [];
              for (const cX of dX.cells) {
                for (const cY of dY.cells) {
                  const deg = cX.dim + cY.dim;
                  const cnt = cX.count * cY.count;
                  const label = cX.label + ' \u2297 ' + cY.label;
                  productCells.push({deg, cnt, label, dimX: cX.dim, dimY: cY.dim});
                }
              }

              const byDeg = {};
              let maxDeg = 0;
              for (const pc of productCells) {
                if (!byDeg[pc.deg]) byDeg[pc.deg] = [];
                byDeg[pc.deg].push(pc);
                if (pc.deg > maxDeg) maxDeg = pc.deg;
              }

              const startY = 65;
              const boxW = Math.min(180, (width - 60) / (maxDeg + 1));
              const boxH = 55;
              const gap = 8;

              for (let d = 0; d <= maxDeg; d++) {
                const x0 = 20 + d * (boxW + gap);
                const cells = byDeg[d] || [];

                const isHighlighted = viz.state.highlightDeg === d;
                ctx.fillStyle = isHighlighted ? '#e74c3c' : '#7f8c8d';
                ctx.font = 'bold 14px serif';
                ctx.textAlign = 'center';
                ctx.fillText('deg ' + d, x0 + boxW / 2, startY);

                cells.forEach((pc, i) => {
                  const y0 = startY + 12 + i * (boxH + 6);
                  const pulse = isHighlighted ? 0.15 + 0.1 * Math.sin(t * 3) : 0;

                  const colors = ['rgba(46,204,113,', 'rgba(52,152,219,', 'rgba(231,76,60,', 'rgba(155,89,182,', 'rgba(241,196,15,'];
                  const colIdx = pc.deg % colors.length;
                  ctx.fillStyle = colors[colIdx] + (0.15 + pulse) + ')';
                  ctx.fillRect(x0, y0, boxW, boxH);
                  ctx.strokeStyle = colors[colIdx] + '0.6)';
                  ctx.lineWidth = isHighlighted ? 2.5 : 1.5;
                  ctx.strokeRect(x0, y0, boxW, boxH);

                  if (viz.state.showLabels) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '13px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(pc.label, x0 + boxW / 2, y0 + 22);
                    ctx.font = '12px serif';
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillText('(' + pc.cnt + ' cell' + (pc.cnt > 1 ? 's' : '') + ')', x0 + boxW / 2, y0 + 40);
                  }
                });
              }

              let totalCells = 0;
              for (const pc of productCells) totalCells += pc.cnt;
              ctx.fillStyle = '#2c3e50';
              ctx.font = '15px serif';
              ctx.textAlign = 'left';
              ctx.fillText('Total cells in product: ' + totalCells, 20, height - 55);

              const betti = {};
              for (let d = 0; d <= maxDeg; d++) {
                betti[d] = 0;
                if (byDeg[d]) {
                  for (const pc of byDeg[d]) betti[d] += pc.cnt;
                }
              }
              let bettiStr = 'Cell count by degree: ';
              for (let d = 0; d <= maxDeg; d++) {
                bettiStr += 'c' + d + '=' + betti[d];
                if (d < maxDeg) bettiStr += ', ';
              }
              ctx.fillText(bettiStr, 20, height - 32);

              ctx.fillStyle = '#7f8c8d';
              ctx.font = '13px serif';
              ctx.fillText('dim(e_X \u2297 e_Y) = dim(e_X) + dim(e_Y)', 20, height - 10);
            },
            controls: [
              {
                type: 'select',
                label: 'Space X',
                options: [
                  { value: 'S1', label: 'S\u00B9' },
                  { value: 'S2', label: 'S\u00B2' },
                  { value: 'I', label: 'Interval I' },
                  { value: 'T2', label: 'T\u00B2' }
                ],
                action: (viz, value) => { viz.state.spaceX = value; }
              },
              {
                type: 'select',
                label: 'Space Y',
                options: [
                  { value: 'S1', label: 'S\u00B9' },
                  { value: 'S2', label: 'S\u00B2' },
                  { value: 'I', label: 'Interval I' },
                  { value: 'T2', label: 'T\u00B2' }
                ],
                action: (viz, value) => { viz.state.spaceY = value; }
              },
              {
                type: 'select',
                label: 'Highlight degree',
                options: [
                  { value: '-1', label: 'None' },
                  { value: '0', label: 'Degree 0' },
                  { value: '1', label: 'Degree 1' },
                  { value: '2', label: 'Degree 2' },
                  { value: '3', label: 'Degree 3' },
                  { value: '4', label: 'Degree 4' }
                ],
                action: (viz, value) => { viz.state.highlightDeg = parseInt(value); }
              }
            ]
          }
        }
      ],
      exercises: [
        {
          id: 'tensor-chain-ex1',
          question: 'Let \\(C_*\\) be the cellular chain complex of \\(S^1\\) (with \\(C_0 = \\mathbb{Z}, C_1 = \\mathbb{Z}\\), all other terms zero, \\(\\partial_1 = 0\\)). Compute the chain complex \\(C_* \\otimes C_*\\) and verify that its homology gives \\(H_*(T^2; \\mathbb{Z})\\).',
          hint: 'The tensor product has \\((C \\otimes C)_0 = \\mathbb{Z}\\), \\((C \\otimes C)_1 = \\mathbb{Z}^2\\), \\((C \\otimes C)_2 = \\mathbb{Z}\\). Compute the differentials using the Koszul sign rule.',
          solution: `The cellular chain complex of \\(S^1\\) is \\(C_0 = \\mathbb{Z}\\langle v \\rangle\\), \\(C_1 = \\mathbb{Z}\\langle e \\rangle\\), with \\(\\partial_1(e) = 0\\) (since the 1-cell wraps around and both endpoints map to the single 0-cell).

Tensor product \\(C_* \\otimes C_*\\):
\\[(C \\otimes C)_0 = C_0 \\otimes C_0 = \\mathbb{Z}\\langle v \\otimes v \\rangle\\]
\\[(C \\otimes C)_1 = (C_1 \\otimes C_0) \\oplus (C_0 \\otimes C_1) = \\mathbb{Z}\\langle e \\otimes v \\rangle \\oplus \\mathbb{Z}\\langle v \\otimes e \\rangle \\cong \\mathbb{Z}^2\\]
\\[(C \\otimes C)_2 = C_1 \\otimes C_1 = \\mathbb{Z}\\langle e \\otimes e \\rangle\\]

Differentials:
\\[\\partial(e \\otimes v) = (\\partial e) \\otimes v = 0, \\quad \\partial(v \\otimes e) = v \\otimes (\\partial e) = 0\\]
\\[\\partial(e \\otimes e) = (\\partial e) \\otimes e + (-1)^1 e \\otimes (\\partial e) = 0 + 0 = 0\\]

So all differentials are zero. Thus:
\\[H_0 = \\mathbb{Z}, \\quad H_1 = \\mathbb{Z}^2, \\quad H_2 = \\mathbb{Z}\\]

This matches \\(H_*(T^2; \\mathbb{Z})\\). \\(\\checkmark\\)`
        }
      ]
    },

    // ============================================================
    // Section 2: The Tor Functor
    // ============================================================
    {
      id: 'tor-functor',
      title: 'The Tor Functor',
      content: `
        <div class="env-block intuition">
          <p><strong>Motivation:</strong> The tensor product \\(- \\otimes B\\) is a right-exact functor: it preserves surjections but can fail to preserve injections. The <em>Tor functor</em> measures this failure. For computing homology of product spaces, \\(\\text{Tor}\\) provides the correction to the naive formula \\(H_n(X \\times Y) \\cong \\bigoplus_{p+q=n} H_p(X) \\otimes H_q(Y)\\).</p>
        </div>

        <div class="env-block definition">
          <p><strong>Definition (Tor via Free Resolution):</strong> For abelian groups \\(A\\) and \\(B\\), choose a free resolution of \\(A\\):</p>
          \\[
          0 \\to F_1 \\xrightarrow{\\phi} F_0 \\xrightarrow{\\varepsilon} A \\to 0
          \\]
          <p>Apply \\(- \\otimes B\\) to get:</p>
          \\[
          F_1 \\otimes B \\xrightarrow{\\phi \\otimes \\text{id}} F_0 \\otimes B \\to A \\otimes B \\to 0
          \\]
          <p>Then:</p>
          \\[
          \\text{Tor}_1(A, B) = \\ker(\\phi \\otimes \\text{id}: F_1 \\otimes B \\to F_0 \\otimes B)
          \\]
          <p>This is independent of the choice of free resolution.</p>
        </div>

        <div class="env-block theorem">
          <p><strong>Key Properties of Tor:</strong></p>
          <ul>
            <li>\\(\\text{Tor}(A, B) \\cong \\text{Tor}(B, A)\\) (symmetry).</li>
            <li>\\(\\text{Tor}(A, B) = 0\\) if \\(A\\) or \\(B\\) is free (or torsion-free over \\(\\mathbb{Z}\\)).</li>
            <li>\\(\\text{Tor}(\\mathbb{Z}/m, \\mathbb{Z}/n) \\cong \\mathbb{Z}/\\gcd(m,n)\\).</li>
            <li>\\(\\text{Tor}(A \\oplus A', B) \\cong \\text{Tor}(A, B) \\oplus \\text{Tor}(A', B)\\).</li>
            <li>\\(\\text{Tor}(\\mathbb{Z}/n, B) \\cong \\ker(n \\cdot: B \\to B) = \\{b \\in B : nb = 0\\}\\) (the \\(n\\)-torsion subgroup of \\(B\\)).</li>
          </ul>
        </div>

        <div class="env-block proof">
          <p><strong>Proof of \\(\\text{Tor}(\\mathbb{Z}/m, \\mathbb{Z}/n) \\cong \\mathbb{Z}/\\gcd(m,n)\\):</strong></p>
          <p>Free resolution of \\(\\mathbb{Z}/m\\):</p>
          \\[
          0 \\to \\mathbb{Z} \\xrightarrow{\\times m} \\mathbb{Z} \\to \\mathbb{Z}/m \\to 0
          \\]
          <p>Tensor with \\(\\mathbb{Z}/n\\):</p>
          \\[
          \\mathbb{Z}/n \\xrightarrow{\\times m} \\mathbb{Z}/n
          \\]
          <p>The kernel of multiplication by \\(m\\) on \\(\\mathbb{Z}/n\\) consists of elements \\(k\\) with \\(mk \\equiv 0 \\pmod{n}\\), i.e., \\(k \\in \\frac{n}{\\gcd(m,n)}\\mathbb{Z}/n\\mathbb{Z} \\cong \\mathbb{Z}/\\gcd(m,n)\\). \\(\\square\\)</p>
        </div>

        <div class="env-block example">
          <p><strong>Example (Tor Computations):</strong></p>
          <ul>
            <li>\\(\\text{Tor}(\\mathbb{Z}/2, \\mathbb{Z}/2) = \\mathbb{Z}/2\\) since \\(\\gcd(2,2)=2\\).</li>
            <li>\\(\\text{Tor}(\\mathbb{Z}/2, \\mathbb{Z}/3) = 0\\) since \\(\\gcd(2,3)=1\\).</li>
            <li>\\(\\text{Tor}(\\mathbb{Z}/6, \\mathbb{Z}/4) = \\mathbb{Z}/\\gcd(6,4) = \\mathbb{Z}/2\\).</li>
            <li>\\(\\text{Tor}(\\mathbb{Z}, \\mathbb{Z}/n) = 0\\) since \\(\\mathbb{Z}\\) is free.</li>
            <li>\\(\\text{Tor}(\\mathbb{Z}/2 \\oplus \\mathbb{Z}/3, \\mathbb{Z}/6) = \\mathbb{Z}/2 \\oplus \\mathbb{Z}/3\\).</li>
          </ul>
        </div>

        <div class="env-block remark">
          <p><strong>Intuition for Tor:</strong> \\(\\text{Tor}(A, B)\\) detects the interaction between torsion in \\(A\\) and torsion in \\(B\\). If either group is torsion-free, \\(\\text{Tor}\\) vanishes. Geometrically, when \\(H_p(X)\\) and \\(H_q(Y)\\) both have torsion, the product space \\(X \\times Y\\) has extra homological information in degree \\(p+q+1\\) that isn't captured by the tensor product alone.</p>
        </div>

        <div class="env-block definition">
          <p><strong>Relating Tor and Ext:</strong> Both are derived functors that measure failures of exactness:</p>
          <ul>
            <li>\\(\\text{Tor}_1(A, B)\\): failure of \\(A \\otimes -\\) to preserve injections (left-derived of \\(\\otimes\\)).</li>
            <li>\\(\\text{Ext}^1(A, B)\\): failure of \\(\\text{Hom}(A, -)\\) to preserve surjections (right-derived of Hom).</li>
          </ul>
          <p>Tor appears in the Künneth formula for homology; Ext appears in the Universal Coefficient Theorem for cohomology.</p>
        </div>
      `,
      visualizations: [
        {
          id: 'tor-calculator',
          title: 'Tor Calculator',
          description: 'Compute Tor(A, B) for cyclic groups step by step via free resolutions',
          canvas: {
            setup: (viz) => {
              viz.state = {
                groupA: 'Z2',
                groupB: 'Z4',
                showResolution: true
              };
            },
            draw: (viz, ctx, width, height) => {
              ctx.clearRect(0, 0, width, height);

              const groups = {
                Z: { name: 'Z', display: '\u2124', n: 0, isFree: true },
                Z2: { name: 'Z/2', display: '\u2124/2', n: 2, isFree: false },
                Z3: { name: 'Z/3', display: '\u2124/3', n: 3, isFree: false },
                Z4: { name: 'Z/4', display: '\u2124/4', n: 4, isFree: false },
                Z6: { name: 'Z/6', display: '\u2124/6', n: 6, isFree: false }
              };

              const A = groups[viz.state.groupA];
              const B = groups[viz.state.groupB];

              function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }

              let torResult;
              if (A.isFree || B.isFree) {
                torResult = '0';
              } else {
                const g = gcd(A.n, B.n);
                torResult = g === 1 ? '0' : '\u2124/' + g;
              }

              let tensorResult;
              if (A.isFree) {
                tensorResult = B.display;
              } else if (B.isFree) {
                tensorResult = A.display;
              } else {
                const g = gcd(A.n, B.n);
                tensorResult = g === 1 ? '0' : '\u2124/' + g;
              }

              const cx = width / 2;

              ctx.fillStyle = '#2c3e50';
              ctx.font = 'bold 18px serif';
              ctx.textAlign = 'center';
              ctx.fillText('Tor(' + A.display + ', ' + B.display + ') via Free Resolution', cx, 28);

              if (viz.state.showResolution && !A.isFree) {
                const resY = 70;
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 14px serif';
                ctx.textAlign = 'left';
                ctx.fillText('Step 1: Free resolution of A = ' + A.display, 20, resY);

                ctx.font = '14px serif';
                ctx.textAlign = 'center';
                const seqY = resY + 35;

                const positions = [cx - 200, cx - 110, cx, cx + 110, cx + 200];
                const labels = ['0', '\u2124', '\u2124', A.display, '0'];
                const arrows = ['', '\u00D7' + A.n, 'proj', '', ''];

                labels.forEach((label, i) => {
                  ctx.fillStyle = '#2c3e50';
                  ctx.font = '15px serif';
                  ctx.fillText(label, positions[i], seqY);

                  if (i < labels.length - 1) {
                    const fromX = positions[i] + 20;
                    const toX = positions[i + 1] - 20;
                    ctx.strokeStyle = '#7f8c8d';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(fromX, seqY - 3);
                    ctx.lineTo(toX, seqY - 3);
                    ctx.stroke();
                    ctx.fillStyle = '#7f8c8d';
                    ctx.beginPath();
                    ctx.moveTo(toX, seqY - 3);
                    ctx.lineTo(toX - 6, seqY - 7);
                    ctx.lineTo(toX - 6, seqY + 1);
                    ctx.fill();

                    if (arrows[i + 1]) {
                      ctx.fillStyle = '#e74c3c';
                      ctx.font = '12px serif';
                      ctx.fillText(arrows[i + 1], (fromX + toX) / 2, seqY - 12);
                    }
                  }
                });

                const tenY = seqY + 55;
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 14px serif';
                ctx.textAlign = 'left';
                ctx.fillText('Step 2: Tensor with B = ' + B.display, 20, tenY);

                ctx.font = '14px serif';
                ctx.textAlign = 'center';
                const seq2Y = tenY + 35;

                const bDisp = B.isFree ? '\u2124' : B.display;
                const pos2 = [cx - 100, cx + 100];
                ctx.fillStyle = '#3498db';
                ctx.font = '15px serif';
                ctx.fillText(bDisp, pos2[0], seq2Y);
                ctx.fillText(bDisp, pos2[1], seq2Y);

                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pos2[0] + 30, seq2Y - 3);
                ctx.lineTo(pos2[1] - 30, seq2Y - 3);
                ctx.stroke();
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(pos2[1] - 30, seq2Y - 3);
                ctx.lineTo(pos2[1] - 36, seq2Y - 7);
                ctx.lineTo(pos2[1] - 36, seq2Y + 1);
                ctx.fill();
                ctx.font = '13px serif';
                ctx.fillText('\u00D7' + A.n, cx, seq2Y - 13);

                const resltY = seq2Y + 55;
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 14px serif';
                ctx.textAlign = 'left';
                ctx.fillText('Step 3: Tor = kernel of this map', 20, resltY);

                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 3;
                const boxW = 200;
                const boxH = 50;
                ctx.strokeRect(cx - boxW / 2, resltY + 15, boxW, boxH);
                ctx.fillStyle = '#27ae60';
                ctx.font = 'bold 22px serif';
                ctx.textAlign = 'center';
                ctx.fillText('Tor = ' + torResult, cx, resltY + 47);
              } else {
                const resY = height / 2 - 30;
                ctx.fillStyle = '#27ae60';
                ctx.font = 'bold 14px serif';
                ctx.textAlign = 'center';
                if (A.isFree) {
                  ctx.fillText('A = ' + A.display + ' is free, so Tor(A, B) = 0 for any B', cx, resY);
                } else if (B.isFree) {
                  ctx.fillText('B = ' + B.display + ' is free, so Tor(A, B) = 0 for any A', cx, resY);
                }

                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 3;
                ctx.strokeRect(cx - 80, resY + 15, 160, 50);
                ctx.fillStyle = '#27ae60';
                ctx.font = 'bold 22px serif';
                ctx.fillText('Tor = 0', cx, resY + 47);
              }

              const bottomY = height - 35;
              ctx.fillStyle = '#7f8c8d';
              ctx.font = '13px serif';
              ctx.textAlign = 'center';
              ctx.fillText('For comparison: ' + A.display + ' \u2297 ' + B.display + ' = ' + tensorResult, cx, bottomY);
            },
            controls: [
              {
                type: 'select',
                label: 'Group A',
                options: [
                  { value: 'Z', label: '\u2124 (free)' },
                  { value: 'Z2', label: '\u2124/2' },
                  { value: 'Z3', label: '\u2124/3' },
                  { value: 'Z4', label: '\u2124/4' },
                  { value: 'Z6', label: '\u2124/6' }
                ],
                action: (viz, value) => { viz.state.groupA = value; }
              },
              {
                type: 'select',
                label: 'Group B',
                options: [
                  { value: 'Z', label: '\u2124 (free)' },
                  { value: 'Z2', label: '\u2124/2' },
                  { value: 'Z3', label: '\u2124/3' },
                  { value: 'Z4', label: '\u2124/4' },
                  { value: 'Z6', label: '\u2124/6' }
                ],
                action: (viz, value) => { viz.state.groupB = value; }
              }
            ]
          }
        }
      ],
      exercises: [
        {
          id: 'tor-computation-ex1',
          question: 'Compute \\(\\text{Tor}(\\mathbb{Z}/4 \\oplus \\mathbb{Z}, \\mathbb{Z}/6)\\) using the properties of Tor.',
          hint: 'Use additivity: \\(\\text{Tor}(A \\oplus B, C) = \\text{Tor}(A, C) \\oplus \\text{Tor}(B, C)\\). Also, Tor vanishes if one factor is free.',
          solution: `By additivity of Tor:
\\[
\\text{Tor}(\\mathbb{Z}/4 \\oplus \\mathbb{Z}, \\mathbb{Z}/6) = \\text{Tor}(\\mathbb{Z}/4, \\mathbb{Z}/6) \\oplus \\text{Tor}(\\mathbb{Z}, \\mathbb{Z}/6)
\\]

\\(\\text{Tor}(\\mathbb{Z}/4, \\mathbb{Z}/6) = \\mathbb{Z}/\\gcd(4,6) = \\mathbb{Z}/2\\).

\\(\\text{Tor}(\\mathbb{Z}, \\mathbb{Z}/6) = 0\\) since \\(\\mathbb{Z}\\) is free.

Therefore:
\\[
\\text{Tor}(\\mathbb{Z}/4 \\oplus \\mathbb{Z}, \\mathbb{Z}/6) = \\mathbb{Z}/2 \\oplus 0 = \\mathbb{Z}/2
\\]
\\(\\square\\)`
        }
      ]
    },

    // ============================================================
    // Section 3: Künneth Theorem for Homology
    // ============================================================
    {
      id: 'kunneth-homology',
      title: 'Künneth Theorem for Homology',
      content: `
        <div class="env-block theorem">
          <p><strong>Künneth Formula (General Form):</strong> Let \\(C_*\\) and \\(D_*\\) be chain complexes of \\(R\\)-modules, with \\(R\\) a PID and \\(C_*\\) free. There is a natural short exact sequence:</p>
          \\[
          0 \\to \\bigoplus_{p+q=n} H_p(C) \\otimes_R H_q(D) \\xrightarrow{\\times} H_n(C \\otimes D) \\xrightarrow{} \\bigoplus_{p+q=n-1} \\text{Tor}_1^R(H_p(C), H_q(D)) \\to 0
          \\]
          <p>This sequence <strong>splits</strong> (but not naturally).</p>
        </div>

        <div class="env-block theorem">
          <p><strong>Künneth Formula (Topological Form):</strong> For spaces \\(X\\) and \\(Y\\), there is a split short exact sequence:</p>
          \\[
          0 \\to \\bigoplus_{p+q=n} H_p(X; \\mathbb{Z}) \\otimes H_q(Y; \\mathbb{Z}) \\to H_n(X \\times Y; \\mathbb{Z}) \\to \\bigoplus_{p+q=n-1} \\text{Tor}(H_p(X; \\mathbb{Z}), H_q(Y; \\mathbb{Z})) \\to 0
          \\]
          <p>giving the splitting:</p>
          \\[
          H_n(X \\times Y) \\cong \\left(\\bigoplus_{p+q=n} H_p(X) \\otimes H_q(Y)\\right) \\oplus \\left(\\bigoplus_{p+q=n-1} \\text{Tor}(H_p(X), H_q(Y))\\right)
          \\]
        </div>

        <div class="env-block remark">
          <p><strong>Reading the Formula:</strong> The Künneth formula has two parts:</p>
          <ul>
            <li><strong>Tensor part</strong> \\(\\bigoplus_{p+q=n} H_p(X) \\otimes H_q(Y)\\): the "expected" contribution. Think of it as pairing a \\(p\\)-cycle in \\(X\\) with a \\(q\\)-cycle in \\(Y\\) to get an \\(n\\)-cycle in \\(X \\times Y\\).</li>
            <li><strong>Tor part</strong> \\(\\bigoplus_{p+q=n-1} \\text{Tor}(H_p(X), H_q(Y))\\): the "correction" from torsion interactions. This vanishes when either \\(H_*(X)\\) or \\(H_*(Y)\\) is torsion-free.</li>
          </ul>
          <p>Note the index shift: the Tor part sums over \\(p+q = n-1\\), one degree lower.</p>
        </div>

        <div class="env-block proof">
          <p><strong>Proof outline:</strong> By Eilenberg-Zilber, \\(C_*(X \\times Y) \\simeq C_*(X) \\otimes C_*(Y)\\). Now apply the algebraic Künneth theorem to the tensor product of chain complexes. If \\(C_*\\) has free chain groups (which singular chains do), the algebraic Künneth theorem gives the short exact sequence. Splitting follows from the structure theorem for finitely generated abelian groups. \\(\\square\\)</p>
        </div>

        <div class="env-block corollary">
          <p><strong>Corollary (Torsion-Free Case):</strong> If \\(H_*(X; \\mathbb{Z})\\) is torsion-free (i.e., all homology groups are free abelian), then</p>
          \\[
          H_n(X \\times Y; \\mathbb{Z}) \\cong \\bigoplus_{p+q=n} H_p(X; \\mathbb{Z}) \\otimes H_q(Y; \\mathbb{Z}).
          \\]
          <p>This is the most commonly used form -- valid for spheres, tori, CW complexes with free homology, etc.</p>
        </div>

        <div class="env-block corollary">
          <p><strong>Corollary (Field Coefficients):</strong> For any field \\(k\\):</p>
          \\[
          H_n(X \\times Y; k) \\cong \\bigoplus_{p+q=n} H_p(X; k) \\otimes_k H_q(Y; k)
          \\]
          <p>since every module over a field is free, so \\(\\text{Tor} = 0\\).</p>
        </div>

        <div class="env-block example">
          <p><strong>Example (With Torsion: \\(\\mathbb{R}P^2 \\times \\mathbb{R}P^2\\)):</strong></p>
          <p>Homology of \\(\\mathbb{R}P^2\\): \\(H_0 = \\mathbb{Z}\\), \\(H_1 = \\mathbb{Z}/2\\), \\(H_k = 0\\) for \\(k \\geq 2\\).</p>
          <p>Now Tor is non-trivial: \\(\\text{Tor}(\\mathbb{Z}/2, \\mathbb{Z}/2) = \\mathbb{Z}/2\\).</p>

          <p>In degree 2:</p>
          \\[
          \\bigoplus_{p+q=2} H_p \\otimes H_q = (H_0 \\otimes H_2) \\oplus (H_1 \\otimes H_1) \\oplus (H_2 \\otimes H_0) = 0 \\oplus (\\mathbb{Z}/2 \\otimes \\mathbb{Z}/2) \\oplus 0 = \\mathbb{Z}/2
          \\]
          \\[
          \\bigoplus_{p+q=1} \\text{Tor}(H_p, H_q) = \\text{Tor}(H_0, H_1) \\oplus \\text{Tor}(H_1, H_0) = 0 \\oplus 0 = 0
          \\]
          <p>So \\(H_2(\\mathbb{R}P^2 \\times \\mathbb{R}P^2) = \\mathbb{Z}/2\\).</p>

          <p>In degree 3:</p>
          \\[
          \\bigoplus_{p+q=3} H_p \\otimes H_q = 0 \\quad \\text{(no valid pairs with } p,q \\leq 1\\text{)}
          \\]
          \\[
          \\bigoplus_{p+q=2} \\text{Tor}(H_p, H_q) = \\text{Tor}(H_1, H_1) = \\text{Tor}(\\mathbb{Z}/2, \\mathbb{Z}/2) = \\mathbb{Z}/2
          \\]
          <p>So \\(H_3(\\mathbb{R}P^2 \\times \\mathbb{R}P^2) = \\mathbb{Z}/2\\) -- coming entirely from the Tor term! Without the correction, we would incorrectly conclude \\(H_3 = 0\\).</p>
        </div>
      `,
      visualizations: [
        {
          id: 'kunneth-calculator',
          title: 'K\u00FCnneth Calculator',
          description: 'Input H*(X) and H*(Y), compute H*(X x Y) via the K\u00FCnneth formula',
          canvas: {
            setup: (viz) => {
              viz.state = {
                spaceX: 'S1',
                spaceY: 'S1',
                animPhase: 0
              };
              viz.homology = {
                'S1': {name: 'S\u00B9', groups: [{deg: 0, grp: '\u2124', free: 1, torsion: null}, {deg: 1, grp: '\u2124', free: 1, torsion: null}]},
                'S2': {name: 'S\u00B2', groups: [{deg: 0, grp: '\u2124', free: 1, torsion: null}, {deg: 2, grp: '\u2124', free: 1, torsion: null}]},
                'T2': {name: 'T\u00B2', groups: [{deg: 0, grp: '\u2124', free: 1, torsion: null}, {deg: 1, grp: '\u2124\u00B2', free: 2, torsion: null}, {deg: 2, grp: '\u2124', free: 1, torsion: null}]},
                'RP2': {name: '\u211DP\u00B2', groups: [{deg: 0, grp: '\u2124', free: 1, torsion: null}, {deg: 1, grp: '\u2124/2', free: 0, torsion: 2}]},
                'KB': {name: 'Klein', groups: [{deg: 0, grp: '\u2124', free: 1, torsion: null}, {deg: 1, grp: '\u2124 \u2295 \u2124/2', free: 1, torsion: 2}]}
              };
            },
            draw: (viz, ctx, width, height) => {
              ctx.clearRect(0, 0, width, height);
              viz.state.animPhase += 0.01;

              const hX = viz.homology[viz.state.spaceX];
              const hY = viz.homology[viz.state.spaceY];

              ctx.fillStyle = '#2c3e50';
              ctx.font = 'bold 18px serif';
              ctx.textAlign = 'left';
              ctx.fillText('K\u00FCnneth: H*(' + hX.name + ' \u00D7 ' + hY.name + ')', 20, 28);

              ctx.font = '14px serif';
              ctx.fillStyle = '#3498db';
              let yPos = 52;

              ctx.fillText('H*(' + hX.name + '):', 20, yPos);
              let xStr = '';
              for (const g of hX.groups) {
                if (xStr) xStr += ', ';
                xStr += 'H' + g.deg + ' = ' + g.grp;
              }
              ctx.fillStyle = '#2c3e50';
              ctx.fillText(xStr, 20 + ctx.measureText('H*(' + hX.name + '): ').width, yPos);

              yPos += 20;
              ctx.fillStyle = '#e74c3c';
              ctx.fillText('H*(' + hY.name + '):', 20, yPos);
              let yStr = '';
              for (const g of hY.groups) {
                if (yStr) yStr += ', ';
                yStr += 'H' + g.deg + ' = ' + g.grp;
              }
              ctx.fillStyle = '#2c3e50';
              ctx.fillText(yStr, 20 + ctx.measureText('H*(' + hY.name + '): ').width, yPos);

              yPos += 30;
              ctx.fillStyle = '#2c3e50';
              ctx.font = 'bold 15px serif';
              ctx.fillText('Result: H*(' + hX.name + ' \u00D7 ' + hY.name + ')', 20, yPos);

              yPos += 5;
              const maxDeg = Math.max(...hX.groups.map(g => g.deg)) + Math.max(...hY.groups.map(g => g.deg));

              function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
              function sub(n) { const subs = '\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089'; return n < 10 ? subs[n] : '' + n; }
              function sup(n) { const sups = '\u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079'; return n < 10 ? sups[n] : '' + n; }

              for (let n = 0; n <= maxDeg; n++) {
                let tensorFree = 0;
                let tensorTorsionParts = [];
                for (const gx of hX.groups) {
                  for (const gy of hY.groups) {
                    if (gx.deg + gy.deg === n) {
                      tensorFree += gx.free * gy.free;
                      if (gx.torsion && gy.free > 0) {
                        for (let k = 0; k < gy.free; k++) tensorTorsionParts.push(gx.torsion);
                      }
                      if (gy.torsion && gx.free > 0) {
                        for (let k = 0; k < gx.free; k++) tensorTorsionParts.push(gy.torsion);
                      }
                      if (gx.torsion && gy.torsion) {
                        const g = gcd(gx.torsion, gy.torsion);
                        tensorTorsionParts.push(g);
                      }
                    }
                  }
                }

                let torParts = [];
                for (const gx of hX.groups) {
                  for (const gy of hY.groups) {
                    if (gx.deg + gy.deg === n - 1) {
                      if (gx.torsion && gy.torsion) {
                        const g = gcd(gx.torsion, gy.torsion);
                        torParts.push(g);
                      }
                    }
                  }
                }

                let parts = [];
                if (tensorFree > 0) {
                  parts.push(tensorFree === 1 ? '\u2124' : '\u2124' + sup(tensorFree));
                }
                for (const m of tensorTorsionParts) parts.push('\u2124/' + m);
                for (const m of torParts) parts.push('\u2124/' + m);

                if (parts.length === 0) continue;

                yPos += 22;
                const pulse = 0.7 + 0.3 * Math.sin(viz.state.animPhase * 2 + n);

                ctx.fillStyle = `rgba(44, 62, 80, ${pulse})`;
                ctx.font = '14px serif';
                ctx.fillText('H' + sub(n) + ' = ' + parts.join(' \u2295 '), 30, yPos);

                if (torParts.length > 0) {
                  ctx.fillStyle = '#9b59b6';
                  ctx.font = '12px serif';
                  ctx.fillText('  (Tor: ' + torParts.map(m => '\u2124/' + m).join(' \u2295 ') + ')', 30 + ctx.measureText('H' + sub(n) + ' = ' + parts.join(' \u2295 ')).width + 5, yPos);
                }
              }

              ctx.fillStyle = '#7f8c8d';
              ctx.font = '13px serif';
              ctx.textAlign = 'left';
              ctx.fillText('Tor(\u2124/m, \u2124/n) = \u2124/gcd(m,n).  Tor = 0 if either factor is free.', 20, height - 12);
            },
            controls: [
              {
                type: 'select',
                label: 'Space X',
                options: [
                  { value: 'S1', label: 'S\u00B9' },
                  { value: 'S2', label: 'S\u00B2' },
                  { value: 'T2', label: 'T\u00B2' },
                  { value: 'RP2', label: '\u211DP\u00B2' },
                  { value: 'KB', label: 'Klein Bottle' }
                ],
                action: (viz, value) => { viz.state.spaceX = value; }
              },
              {
                type: 'select',
                label: 'Space Y',
                options: [
                  { value: 'S1', label: 'S\u00B9' },
                  { value: 'S2', label: 'S\u00B2' },
                  { value: 'T2', label: 'T\u00B2' },
                  { value: 'RP2', label: '\u211DP\u00B2' },
                  { value: 'KB', label: 'Klein Bottle' }
                ],
                action: (viz, value) => { viz.state.spaceY = value; }
              }
            ]
          }
        }
      ],
      exercises: [
        {
          id: 'kunneth-hom-ex1',
          question: 'Compute \\(H_*(\\mathbb{R}P^2 \\times S^1; \\mathbb{Z})\\) using the Künneth formula. Identify which groups come from the tensor part and which from Tor.',
          hint: 'Recall \\(H_0(\\mathbb{R}P^2) = \\mathbb{Z}\\), \\(H_1(\\mathbb{R}P^2) = \\mathbb{Z}/2\\), \\(H_k = 0\\) for \\(k \\geq 2\\). And \\(H_0(S^1) = \\mathbb{Z}\\), \\(H_1(S^1) = \\mathbb{Z}\\).',
          solution: `Using Künneth with \\(X = \\mathbb{R}P^2\\) and \\(Y = S^1\\):

\\(H_0(X) = \\mathbb{Z}\\), \\(H_1(X) = \\mathbb{Z}/2\\), \\(H_k(X) = 0\\) for \\(k \\geq 2\\).
\\(H_0(Y) = \\mathbb{Z}\\), \\(H_1(Y) = \\mathbb{Z}\\).

Since \\(H_*(S^1)\\) is free, all Tor terms vanish. So \\(H_n(X \\times Y) \\cong \\bigoplus_{p+q=n} H_p(X) \\otimes H_q(Y)\\).

\\[H_0 = H_0(X) \\otimes H_0(Y) = \\mathbb{Z} \\otimes \\mathbb{Z} = \\mathbb{Z}\\]
\\[H_1 = (H_0(X) \\otimes H_1(Y)) \\oplus (H_1(X) \\otimes H_0(Y)) = \\mathbb{Z} \\oplus \\mathbb{Z}/2\\]
\\[H_2 = H_1(X) \\otimes H_1(Y) = \\mathbb{Z}/2 \\otimes \\mathbb{Z} = \\mathbb{Z}/2\\]
\\[H_k = 0 \\text{ for } k \\geq 3\\]

All contributions are from the tensor part; Tor contributes nothing because \\(H_*(S^1)\\) is torsion-free. \\(\\checkmark\\)`
        },
        {
          id: 'kunneth-hom-ex2',
          question: 'Compute \\(H_3(\\mathbb{R}P^2 \\times \\mathbb{R}P^2)\\) using the Künneth formula. Explain why this group would be zero without the Tor correction.',
          hint: 'The only non-zero homology groups of \\(\\mathbb{R}P^2\\) are in degrees 0 and 1. For degree 3, the tensor terms need \\(p+q=3\\), but \\(p, q \\leq 1\\).',
          solution: `Homology of \\(\\mathbb{R}P^2\\): \\(H_0 = \\mathbb{Z}\\), \\(H_1 = \\mathbb{Z}/2\\), \\(H_k = 0\\) for \\(k \\geq 2\\).

Tensor part (sum over \\(p+q=3\\)):
Since \\(H_p(\\mathbb{R}P^2) = 0\\) for \\(p \\geq 2\\), and we need \\(p+q = 3\\) with both \\(p, q \\leq 1\\), there are NO valid pairs. So:
\\[\\bigoplus_{p+q=3} H_p \\otimes H_q = 0\\]

Tor part (sum over \\(p+q=2\\)):
\\(p=1, q=1\\): \\(\\text{Tor}(H_1, H_1) = \\text{Tor}(\\mathbb{Z}/2, \\mathbb{Z}/2) = \\mathbb{Z}/2\\).

Therefore:
\\[H_3(\\mathbb{R}P^2 \\times \\mathbb{R}P^2) = 0 \\oplus \\mathbb{Z}/2 = \\mathbb{Z}/2\\]

Without the Tor correction, we would incorrectly conclude \\(H_3 = 0\\). The Tor term detects the torsion interaction between the two copies of \\(\\mathbb{Z}/2\\) in \\(H_1\\). \\(\\square\\)`
        }
      ]
    },

    // ============================================================
    // Section 4: Künneth for Cohomology and Cross Product
    // ============================================================
    {
      id: 'kunneth-cohomology',
      title: 'K\u00FCnneth for Cohomology and Cross Product',
      content: `
        <div class="env-block definition">
          <p><strong>Definition (Cross Product in Cohomology):</strong> The <strong>cohomology cross product</strong> is the map</p>
          \\[
          \\times: H^p(X; R) \\otimes H^q(Y; R) \\to H^{p+q}(X \\times Y; R)
          \\]
          <p>defined by \\(\\alpha \\times \\beta = \\pi_X^*(\\alpha) \\cup \\pi_Y^*(\\beta)\\), where \\(\\pi_X: X \\times Y \\to X\\) and \\(\\pi_Y: X \\times Y \\to Y\\) are the projection maps.</p>
        </div>

        <div class="env-block theorem">
          <p><strong>Künneth Formula (Cohomology):</strong> For spaces \\(X\\) and \\(Y\\), and a field \\(k\\):</p>
          \\[
          H^n(X \\times Y; k) \\cong \\bigoplus_{p+q=n} H^p(X; k) \\otimes_k H^q(Y; k)
          \\]
          <p>Moreover, the cross product assembles to a <strong>graded ring isomorphism</strong>:</p>
          \\[
          H^*(X \\times Y; k) \\cong H^*(X; k) \\otimes_k H^*(Y; k)
          \\]
          <p>where the right side has the graded tensor product ring structure: \\((\\alpha \\otimes \\beta) \\cdot (\\alpha' \\otimes \\beta') = (-1)^{|\\beta||\\alpha'|}(\\alpha \\cup \\alpha') \\otimes (\\beta \\cup \\beta')\\).</p>
        </div>

        <div class="env-block remark">
          <p><strong>Important:</strong> Over \\(\\mathbb{Z}\\), the cohomology Künneth formula involves a Tor correction:</p>
          \\[
          0 \\to \\bigoplus_{p+q=n} H^p(X) \\otimes H^q(Y) \\to H^n(X \\times Y) \\to \\bigoplus_{p+q=n+1} \\text{Tor}(H^p(X), H^q(Y)) \\to 0
          \\]
          <p>But over a <strong>field</strong>, Tor = 0 and we get a clean isomorphism of graded algebras.</p>
        </div>

        <div class="env-block remark">
          <p><strong>Cross Product vs Cup Product:</strong> For a space \\(X\\), the <em>diagonal map</em> \\(\\Delta: X \\to X \\times X\\) (\\(x \\mapsto (x,x)\\)) relates the cross product and cup product:</p>
          \\[
          \\alpha \\smile \\beta = \\Delta^*(\\alpha \\times \\beta)
          \\]
          <p>The cup product is the "internal" version of the cross product, pulled back along the diagonal.</p>
        </div>

        <div class="env-block example">
          <p><strong>Example (Cohomology Ring of \\(T^2\\)):</strong> Since \\(T^2 = S^1 \\times S^1\\) and \\(H^*(S^1; \\mathbb{Z}) = \\Lambda[\\alpha]\\) (exterior algebra on a degree 1 generator):</p>
          \\[
          H^*(T^2; \\mathbb{Z}) \\cong \\Lambda[\\alpha] \\otimes \\Lambda[\\beta] = \\Lambda[\\alpha, \\beta]
          \\]
          <p>with \\(\\deg(\\alpha) = \\deg(\\beta) = 1\\). The ring structure is:</p>
          <ul>
            <li>\\(\\alpha^2 = 0\\), \\(\\beta^2 = 0\\) (from each \\(\\Lambda\\) factor)</li>
            <li>\\(\\alpha \\cup \\beta = -\\beta \\cup \\alpha\\) (graded commutativity with \\((-1)^{1 \\cdot 1} = -1\\))</li>
            <li>Basis: \\(\\{1, \\alpha, \\beta, \\alpha\\beta\\}\\) with \\(\\alpha\\beta\\) generating \\(H^2(T^2) \\cong \\mathbb{Z}\\)</li>
          </ul>
        </div>

        <div class="env-block example">
          <p><strong>Example (\\(\\mathbb{C}P^n \\times \\mathbb{C}P^m\\)):</strong></p>
          <p>Recall \\(H^*(\\mathbb{C}P^n; \\mathbb{Z}) = \\mathbb{Z}[\\alpha]/(\\alpha^{n+1})\\) with \\(\\deg(\\alpha) = 2\\). By Künneth:</p>
          \\[
          H^*(\\mathbb{C}P^n \\times \\mathbb{C}P^m; \\mathbb{Z}) \\cong \\frac{\\mathbb{Z}[\\alpha]}{(\\alpha^{n+1})} \\otimes \\frac{\\mathbb{Z}[\\beta]}{(\\beta^{m+1})} \\cong \\frac{\\mathbb{Z}[\\alpha, \\beta]}{(\\alpha^{n+1}, \\beta^{m+1})}
          \\]
          <p>with \\(\\deg(\\alpha) = \\deg(\\beta) = 2\\). Since both generators have even degree, the graded tensor product is commutative (no signs).</p>
        </div>

        <div class="env-block remark">
          <p><strong>Why Cohomology is Better for Products:</strong> The Künneth formula over a field gives an isomorphism of <em>rings</em>, not just groups. This is a key advantage of cohomology:</p>
          <ul>
            <li>Homology: \\(H_*(X \\times Y) \\cong H_*(X) \\otimes H_*(Y)\\) as groups.</li>
            <li>Cohomology: \\(H^*(X \\times Y) \\cong H^*(X) \\otimes H^*(Y)\\) as <strong>graded rings</strong>.</li>
          </ul>
          <p>The ring structure is a strictly finer invariant than the group structure.</p>
        </div>

        <div class="env-block theorem">
          <p><strong>Application: Detecting Non-Product Spaces.</strong> If a space \\(Z\\) has the <em>same homology groups</em> as \\(X \\times Y\\) but a <em>different ring structure</em>, then \\(Z \\not\\simeq X \\times Y\\).</p>
          <p><strong>Classic example:</strong> \\(\\mathbb{C}P^2\\) vs \\(S^2 \\vee S^4\\). Both have \\(H^* = (\\mathbb{Z}, 0, \\mathbb{Z}, 0, \\mathbb{Z})\\) as graded groups, but:</p>
          <ul>
            <li>\\(\\mathbb{C}P^2\\): \\(\\alpha^2 \\neq 0\\) (generator of \\(H^4\\))</li>
            <li>\\(S^2 \\vee S^4\\): \\(\\alpha^2 = 0\\) (all cup products of positive-degree classes are zero)</li>
          </ul>
        </div>
      `,
      visualizations: [
        {
          id: 'cross-product-visualizer',
          title: 'Cross Product Visualizer',
          description: 'See how homology classes in X and Y combine via the cross product to give classes in X x Y',
          canvas: {
            setup: (viz) => {
              viz.state = {
                classX: 0,
                classY: 0,
                animPhase: 0,
                showFormula: true
              };
            },
            draw: (viz, ctx, width, height) => {
              ctx.clearRect(0, 0, width, height);
              viz.state.animPhase += 0.015;
              const t = viz.state.animPhase;

              ctx.fillStyle = '#2c3e50';
              ctx.font = 'bold 18px serif';
              ctx.textAlign = 'center';
              ctx.fillText('Cross Product: \u03B1 \u00D7 \u03B2 \u2208 H*(X \u00D7 Y)', width / 2, 28);

              const cx = width / 2;
              const cy = height / 2;

              // Draw X = S^1 on the left
              const leftX = width * 0.18;
              const leftY = cy - 20;
              const rSmall = 45;

              ctx.strokeStyle = '#3498db';
              ctx.lineWidth = 2.5;
              ctx.beginPath();
              ctx.arc(leftX, leftY, rSmall, 0, Math.PI * 2);
              ctx.stroke();

              ctx.fillStyle = '#3498db';
              ctx.font = 'bold 14px serif';
              ctx.textAlign = 'center';
              ctx.fillText('X = S\u00B9', leftX, leftY - rSmall - 12);

              if (viz.state.classX === 1) {
                const glow = 0.5 + 0.5 * Math.sin(t * 2);
                ctx.strokeStyle = `rgba(231, 76, 60, ${glow})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(leftX, leftY, rSmall, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 14px serif';
                ctx.fillText('\u03B1 \u2208 H\u2081(S\u00B9)', leftX, leftY + rSmall + 20);
              } else {
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(leftX, leftY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '14px serif';
                ctx.fillText('1 \u2208 H\u2080(S\u00B9)', leftX, leftY + rSmall + 20);
              }

              // Draw Y = S^1 on the right
              const rightX = width * 0.82;
              const rightY = cy - 20;

              ctx.strokeStyle = '#3498db';
              ctx.lineWidth = 2.5;
              ctx.beginPath();
              ctx.arc(rightX, rightY, rSmall, 0, Math.PI * 2);
              ctx.stroke();

              ctx.fillStyle = '#3498db';
              ctx.font = 'bold 14px serif';
              ctx.fillText('Y = S\u00B9', rightX, rightY - rSmall - 12);

              if (viz.state.classY === 1) {
                const glow = 0.5 + 0.5 * Math.sin(t * 2 + 1);
                ctx.strokeStyle = `rgba(155, 89, 182, ${glow})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(rightX, rightY, rSmall, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#9b59b6';
                ctx.font = 'bold 14px serif';
                ctx.fillText('\u03B2 \u2208 H\u2081(S\u00B9)', rightX, rightY + rSmall + 20);
              } else {
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(rightX, rightY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '14px serif';
                ctx.fillText('1 \u2208 H\u2080(S\u00B9)', rightX, rightY + rSmall + 20);
              }

              // Arrow
              ctx.strokeStyle = '#7f8c8d';
              ctx.lineWidth = 1.5;
              ctx.setLineDash([6, 4]);
              ctx.beginPath();
              ctx.moveTo(leftX + rSmall + 15, leftY);
              ctx.lineTo(cx - 55, leftY);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(rightX - rSmall - 15, rightY);
              ctx.lineTo(cx + 55, rightY);
              ctx.stroke();
              ctx.setLineDash([]);

              // Cross product symbol
              ctx.fillStyle = '#27ae60';
              ctx.font = 'bold 24px serif';
              ctx.textAlign = 'center';
              ctx.fillText('\u00D7', cx, cy - 15);

              // Draw product in T^2 below
              const productY = height - 75;
              const degX = viz.state.classX;
              const degY = viz.state.classY;
              const totalDeg = degX + degY;

              ctx.fillStyle = '#27ae60';
              ctx.font = 'bold 15px serif';
              ctx.textAlign = 'center';

              const classNames = {
                '0,0': '1 \u00D7 1 = 1 \u2208 H\u2080(T\u00B2)       [the point class]',
                '1,0': '\u03B1 \u00D7 1 \u2208 H\u2081(T\u00B2)       [meridian cycle]',
                '0,1': '1 \u00D7 \u03B2 \u2208 H\u2081(T\u00B2)       [longitude cycle]',
                '1,1': '\u03B1 \u00D7 \u03B2 \u2208 H\u2082(T\u00B2)     [fundamental class [T\u00B2]]'
              };

              const key = degX + ',' + degY;
              ctx.fillText(classNames[key] || '', cx, productY);

              if (viz.state.showFormula) {
                ctx.fillStyle = 'rgba(44, 62, 80, 0.05)';
                ctx.fillRect(15, height - 50, width - 30, 42);
                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.strokeRect(15, height - 50, width - 30, 42);

                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px serif';
                ctx.textAlign = 'center';
                ctx.fillText('\u03B1 \u00D7 \u03B2 = EZ(\u03B1 \u2297 \u03B2) \u2208 H_{p+q}(X \u00D7 Y),   deg(\u03B1\u00D7\u03B2) = deg(\u03B1) + deg(\u03B2) = ' + degX + '+' + degY + ' = ' + totalDeg, cx, height - 24);
              }
            },
            controls: [
              {
                type: 'select',
                label: 'Class in X',
                options: [
                  { value: '0', label: '1 \u2208 H\u2080(S\u00B9)' },
                  { value: '1', label: '\u03B1 \u2208 H\u2081(S\u00B9)' }
                ],
                action: (viz, value) => { viz.state.classX = parseInt(value); }
              },
              {
                type: 'select',
                label: 'Class in Y',
                options: [
                  { value: '0', label: '1 \u2208 H\u2080(S\u00B9)' },
                  { value: '1', label: '\u03B2 \u2208 H\u2081(S\u00B9)' }
                ],
                action: (viz, value) => { viz.state.classY = parseInt(value); }
              }
            ]
          }
        }
      ],
      exercises: [
        {
          id: 'kunneth-cohom-ex1',
          question: 'Compute the cohomology ring \\(H^*(S^2 \\times S^3; \\mathbb{Z})\\) using the Künneth formula. List all generators, their degrees, and the full multiplication table.',
          hint: 'Use \\(H^*(S^n; \\mathbb{Z}) = \\mathbb{Z}[x]/(x^2)\\) with \\(\\deg(x) = n\\). The cross product gives \\(H^*(S^m \\times S^n) = \\Lambda[\\alpha, \\beta]\\) with appropriate degrees.',
          solution: `\\(H^*(S^2; \\mathbb{Z}) = \\mathbb{Z}\\langle 1, \\alpha \\rangle\\) with \\(\\deg(\\alpha) = 2\\), \\(\\alpha^2 = 0\\).
\\(H^*(S^3; \\mathbb{Z}) = \\mathbb{Z}\\langle 1, \\beta \\rangle\\) with \\(\\deg(\\beta) = 3\\), \\(\\beta^2 = 0\\).

By Künneth (both are torsion-free):
\\[H^*(S^2 \\times S^3; \\mathbb{Z}) \\cong H^*(S^2) \\otimes H^*(S^3) = \\mathbb{Z}\\langle 1, \\alpha, \\beta, \\alpha\\beta \\rangle\\]

Degrees:
\\[H^0 = \\mathbb{Z}\\langle 1 \\rangle, \\quad H^2 = \\mathbb{Z}\\langle \\alpha \\rangle, \\quad H^3 = \\mathbb{Z}\\langle \\beta \\rangle, \\quad H^5 = \\mathbb{Z}\\langle \\alpha\\beta \\rangle\\]

Multiplication table:
\\[\\alpha^2 = 0, \\quad \\beta^2 = 0, \\quad \\alpha\\beta = (-1)^{2 \\cdot 3}\\beta\\alpha = \\beta\\alpha\\]

Note: \\(H^1 = H^4 = 0\\). The ring is the exterior algebra \\(\\Lambda_{\\mathbb{Z}}[\\alpha, \\beta]\\) on generators of degrees 2 and 3. Since \\(2 \\cdot 3 = 6\\) is even, \\(\\alpha\\) and \\(\\beta\\) actually commute. \\(\\checkmark\\)`
        }
      ]
    },

    // ============================================================
    // Section 5: Examples and Applications
    // ============================================================
    {
      id: 'examples-computations',
      title: 'Examples: Tori, Spheres, and Applications',
      content: `
        <div class="env-block example">
          <p><strong>Example 1: \\(T^2 = S^1 \\times S^1\\) (The Torus).</strong></p>
          <p>\\(H_*(S^1) = (\\mathbb{Z}, \\mathbb{Z}, 0, 0, \\ldots)\\), all free. By Künneth:</p>
          \\[
          H_n(T^2) = \\bigoplus_{p+q=n} H_p(S^1) \\otimes H_q(S^1)
          \\]
          <ul>
            <li>\\(H_0(T^2) = \\mathbb{Z} \\otimes \\mathbb{Z} = \\mathbb{Z}\\)</li>
            <li>\\(H_1(T^2) = (\\mathbb{Z} \\otimes \\mathbb{Z}) \\oplus (\\mathbb{Z} \\otimes \\mathbb{Z}) = \\mathbb{Z}^2\\)</li>
            <li>\\(H_2(T^2) = \\mathbb{Z} \\otimes \\mathbb{Z} = \\mathbb{Z}\\)</li>
          </ul>
          <p>The two generators of \\(H_1(T^2)\\) are the <strong>meridian</strong> \\(\\alpha \\times 1\\) and the <strong>longitude</strong> \\(1 \\times \\beta\\), while the generator of \\(H_2(T^2)\\) is the fundamental class \\(\\alpha \\times \\beta = [T^2]\\).</p>
        </div>

        <div class="env-block example">
          <p><strong>Example 2: Higher-Dimensional Tori \\(T^n = (S^1)^n\\).</strong></p>
          <p>By induction on \\(n\\) using Künneth:</p>
          \\[
          H_k(T^n; \\mathbb{Z}) = \\mathbb{Z}^{\\binom{n}{k}}, \\qquad 0 \\leq k \\leq n.
          \\]
          <p>The Poincare polynomial is</p>
          \\[
          P_{T^n}(t) = \\sum_k \\binom{n}{k} t^k = (1 + t)^n.
          \\]
          <p>This reflects the exterior algebra structure: \\(H^*(T^n) = \\Lambda[\\alpha_1, \\ldots, \\alpha_n]\\).</p>
        </div>

        <div class="env-block example">
          <p><strong>Example 3: \\(S^n \\times S^m\\) (Sphere Products).</strong></p>
          <p>Since \\(H_*(S^k) = (\\mathbb{Z}, 0, \\ldots, 0, \\mathbb{Z}, 0, \\ldots)\\) with the nonzero groups in degrees 0 and \\(k\\):</p>
          \\[
          H_i(S^n \\times S^m) = \\begin{cases}
          \\mathbb{Z} & i = 0 \\\\
          \\mathbb{Z} & i = n \\text{ (if } n \\neq m\\text{)} \\\\
          \\mathbb{Z} & i = m \\text{ (if } n \\neq m\\text{)} \\\\
          \\mathbb{Z}^2 & i = n = m \\\\
          \\mathbb{Z} & i = n + m \\\\
          0 & \\text{otherwise}
          \\end{cases}
          \\]
        </div>

        <div class="env-block theorem">
          <p><strong>Application 1 (Poincare Series):</strong> The <em>Poincare series</em> \\(P_X(t) = \\sum_k b_k(X) \\, t^k\\) (where \\(b_k = \\text{rank}\\, H_k(X)\\)) satisfies:</p>
          \\[
          P_{X \\times Y}(t) = P_X(t) \\cdot P_Y(t)
          \\]
          <p>when homology is torsion-free. Examples:</p>
          <ul>
            <li>\\(P_{S^1}(t) = 1 + t\\), so \\(P_{T^n}(t) = (1+t)^n = \\sum_k \\binom{n}{k} t^k\\).</li>
            <li>\\(P_{S^2}(t) = 1 + t^2\\), so \\(P_{S^2 \\times S^3}(t) = (1+t^2)(1+t^3) = 1 + t^2 + t^3 + t^5\\).</li>
          </ul>
        </div>

        <div class="env-block theorem">
          <p><strong>Application 2 (Euler Characteristic of Products):</strong> For finite CW complexes \\(X\\) and \\(Y\\):</p>
          \\[
          \\chi(X \\times Y) = \\chi(X) \\cdot \\chi(Y)
          \\]
          <p><strong>Proof:</strong> \\(\\chi(X) = P_X(-1)\\), so \\(\\chi(X \\times Y) = P_{X \\times Y}(-1) = P_X(-1) \\cdot P_Y(-1) = \\chi(X) \\cdot \\chi(Y)\\). \\(\\square\\)</p>
        </div>

        <div class="env-block theorem">
          <p><strong>Application 3 (Reduced Künneth / Smash Product):</strong> For well-pointed spaces:</p>
          \\[
          \\widetilde{H}_n(X \\wedge Y) \\cong \\bigoplus_{p+q=n} \\widetilde{H}_p(X) \\otimes \\widetilde{H}_q(Y) \\oplus \\bigoplus_{p+q=n-1} \\text{Tor}(\\widetilde{H}_p(X), \\widetilde{H}_q(Y))
          \\]
          <p>Example: \\(S^m \\wedge S^n \\cong S^{m+n}\\), and indeed \\(\\widetilde{H}_k(S^m) \\otimes \\widetilde{H}_l(S^n) = \\mathbb{Z}\\) only for \\(k = m, l = n\\), giving \\(\\widetilde{H}_{m+n} = \\mathbb{Z}\\). \\(\\checkmark\\)</p>
        </div>

        <div class="env-block example">
          <p><strong>Example 4: Distinguishing \\(S^2 \\times S^4\\) from \\(\\mathbb{C}P^3\\).</strong></p>
          <p>Both have \\(H_* = (\\mathbb{Z}, 0, \\mathbb{Z}, 0, \\mathbb{Z}, 0, \\mathbb{Z})\\). But the cohomology rings differ:</p>
          <ul>
            <li>\\(S^2 \\times S^4\\): \\(H^* = \\Lambda[\\alpha, \\beta]\\) with \\(\\deg(\\alpha)=2\\), \\(\\deg(\\beta)=4\\). Key: \\(\\alpha^2 = 0\\).</li>
            <li>\\(\\mathbb{C}P^3\\): \\(H^* = \\mathbb{Z}[\\gamma]/(\\gamma^4)\\) with \\(\\deg(\\gamma)=2\\). Key: \\(\\gamma^2 \\neq 0\\) generates \\(H^4\\).</li>
          </ul>
          <p>Since a homotopy equivalence must preserve the ring structure, \\(S^2 \\times S^4 \\not\\simeq \\mathbb{C}P^3\\).</p>
        </div>
      `,
      visualizations: [
        {
          id: 'torus-from-circles',
          title: 'Torus from S\u00B9 \u00D7 S\u00B9',
          description: 'Step-by-step construction of T\u00B2 from two circles, showing how cells combine',
          canvas: {
            setup: (viz) => {
              viz.state = {
                step: 0,
                animPhase: 0
              };
            },
            draw: (viz, ctx, width, height) => {
              ctx.clearRect(0, 0, width, height);
              viz.state.animPhase += 0.015;
              const t = viz.state.animPhase;
              const step = viz.state.step;

              ctx.fillStyle = '#2c3e50';
              ctx.font = 'bold 18px serif';
              ctx.textAlign = 'center';
              const titles = [
                'Step 0: The two circles S\u00B9 and S\u00B9',
                'Step 1: Product of 0-cells (e\u2070 \u2297 e\u2070)',
                'Step 2: Product with 1-cells (two 1-cells)',
                'Step 3: Product of 1-cells (the 2-cell)',
                'Step 4: Complete T\u00B2 = S\u00B9 \u00D7 S\u00B9'
              ];
              ctx.fillText(titles[step], width / 2, 28);

              const cx = width / 2;
              const cy = height / 2;

              if (step === 0) {
                const r = 50;
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cx - 100, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 16px serif';
                ctx.fillText('S\u00B9 (X)', cx - 100, cy - r - 15);
                ctx.font = '13px serif';
                ctx.fillText('e\u2070 + e\u00B9', cx - 100, cy + r + 20);

                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cx + 100, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 16px serif';
                ctx.fillText('S\u00B9 (Y)', cx + 100, cy - r - 15);
                ctx.font = '13px serif';
                ctx.fillText('e\u2070 + e\u00B9', cx + 100, cy + r + 20);

                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(cx - 100 + r, cy, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cx + 100 + r, cy, 5, 0, Math.PI * 2);
                ctx.fill();
              } else if (step === 1) {
                const size = 150;
                const x0 = cx - size / 2;
                const y0 = cy - size / 2;

                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.strokeRect(x0, y0, size, size);
                ctx.setLineDash([]);

                const pulse = 5 + 3 * Math.sin(t * 3);
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(x0, y0, pulse, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#27ae60';
                ctx.font = 'bold 15px serif';
                ctx.fillText('e\u2070 \u2297 e\u2070 = vertex', cx, y0 + size + 35);
                ctx.font = '13px serif';
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('H\u2080(T\u00B2) = \u2124  (one component)', cx, y0 + size + 55);
              } else if (step === 2) {
                const size = 150;
                const x0 = cx - size / 2;
                const y0 = cy - size / 2;

                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.strokeRect(x0, y0, size, size);
                ctx.setLineDash([]);

                const glow1 = 0.5 + 0.5 * Math.sin(t * 2);
                ctx.strokeStyle = `rgba(231, 76, 60, ${glow1})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(x0, y0 + size);
                ctx.lineTo(x0 + size, y0 + size);
                ctx.stroke();

                const glow2 = 0.5 + 0.5 * Math.sin(t * 2 + 1);
                ctx.strokeStyle = `rgba(52, 152, 219, ${glow2})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x0, y0 + size);
                ctx.stroke();

                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(x0, y0 + size, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 13px serif';
                ctx.textAlign = 'left';
                ctx.fillText('e\u00B9_X \u2297 e\u2070_Y  (meridian \u03B1)', x0 + size + 15, y0 + size);

                ctx.fillStyle = '#3498db';
                ctx.fillText('e\u2070_X \u2297 e\u00B9_Y  (longitude \u03B2)', x0 - 5, y0 - 12);

                ctx.fillStyle = '#2c3e50';
                ctx.textAlign = 'center';
                ctx.font = '13px serif';
                ctx.fillText('H\u2081(T\u00B2) = \u2124\u00B2  (two independent 1-cycles)', cx, y0 + size + 55);
              } else if (step === 3) {
                const size = 150;
                const x0 = cx - size / 2;
                const y0 = cy - size / 2;

                const pulse = 0.15 + 0.1 * Math.sin(t * 2);
                ctx.fillStyle = `rgba(155, 89, 182, ${pulse})`;
                ctx.fillRect(x0, y0, size, size);

                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 2.5;
                ctx.strokeRect(x0, y0, size, size);

                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x0, y0 + size);
                ctx.lineTo(x0 + size, y0 + size);
                ctx.stroke();

                ctx.strokeStyle = '#3498db';
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x0, y0 + size);
                ctx.stroke();

                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(x0, y0 + size, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#9b59b6';
                ctx.font = 'bold 16px serif';
                ctx.fillText('e\u00B9 \u2297 e\u00B9', cx, cy);
                ctx.font = '13px serif';
                ctx.fillText('(2-cell = fundamental class)', cx, cy + 20);

                ctx.fillStyle = '#2c3e50';
                ctx.font = '13px serif';
                ctx.fillText('H\u2082(T\u00B2) = \u2124  generated by [T\u00B2] = \u03B1 \u00D7 \u03B2', cx, y0 + size + 55);
              } else if (step === 4) {
                const majorR = 80;
                const minorR = 35;

                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.arc(cx, cy, majorR + minorR, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, majorR - minorR, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = 'rgba(155, 89, 182, 0.1)';
                ctx.beginPath();
                ctx.arc(cx, cy, majorR + minorR, 0, Math.PI * 2);
                ctx.arc(cx, cy, majorR - minorR, Math.PI * 2, 0, true);
                ctx.closePath();
                ctx.fill();

                const mAngle = t * 0.5;
                const mx = cx + majorR * Math.cos(mAngle);
                const my = cy + majorR * Math.sin(mAngle);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(mx, my, minorR, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#e74c3c';
                ctx.font = '13px serif';
                ctx.fillText('\u03B1 (meridian)', mx + minorR + 10, my);

                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.arc(cx, cy, majorR, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#3498db';
                ctx.fillText('\u03B2 (longitude)', cx, cy - majorR - 12);

                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px serif';
                ctx.fillText('T\u00B2 = S\u00B9 \u00D7 S\u00B9:  H* = (\u2124, \u2124\u00B2, \u2124)  by K\u00FCnneth', cx, height - 30);
                ctx.fillText('H*(T\u00B2; \u2124) = \u039B[\u03B1, \u03B2]  (exterior algebra)', cx, height - 10);
              }
            },
            controls: [
              {
                type: 'select',
                label: 'Step',
                options: [
                  { value: '0', label: 'Step 0: Two circles' },
                  { value: '1', label: 'Step 1: 0-cell (vertex)' },
                  { value: '2', label: 'Step 2: 1-cells (edges)' },
                  { value: '3', label: 'Step 3: 2-cell (face)' },
                  { value: '4', label: 'Step 4: Complete T\u00B2' }
                ],
                action: (viz, value) => { viz.state.step = parseInt(value); }
              }
            ]
          }
        },
        {
          id: 'sphere-product-viz',
          title: 'Sphere Products S\u207F \u00D7 S\u1D50',
          description: 'Visualize the homology of S^n x S^m for various n, m via K\u00FCnneth',
          canvas: {
            setup: (viz) => {
              viz.state = {
                n: 1,
                m: 1,
                animPhase: 0,
                showPoincare: true
              };
            },
            draw: (viz, ctx, width, height) => {
              ctx.clearRect(0, 0, width, height);
              viz.state.animPhase += 0.012;
              const t = viz.state.animPhase;

              const n = viz.state.n;
              const m = viz.state.m;

              function sup(k) {
                const s = '\u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079';
                if (k < 10) return s[k];
                return '' + k;
              }
              function sub(k) {
                const s = '\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089';
                if (k < 10) return s[k];
                return '' + k;
              }

              ctx.fillStyle = '#2c3e50';
              ctx.font = 'bold 18px serif';
              ctx.textAlign = 'center';
              ctx.fillText('H*(S' + sup(n) + ' \u00D7 S' + sup(m) + '; \u2124) via K\u00FCnneth', width / 2, 28);

              const maxDeg = n + m;
              const groups = [];
              for (let k = 0; k <= maxDeg; k++) {
                let rank = 0;
                if (k === 0) rank = 1;
                else if (k === n && k === m) rank = 2;
                else if (k === n) rank = 1;
                else if (k === m) rank = 1;
                else if (k === n + m) rank = 1;
                else rank = 0;
                groups.push({deg: k, rank: rank});
              }

              const chartX = 40;
              const chartY = 55;
              const chartW = width - 80;
              const chartH = height - 160;
              const barW = Math.min(60, chartW / (maxDeg + 2));

              ctx.strokeStyle = '#7f8c8d';
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.moveTo(chartX, chartY);
              ctx.lineTo(chartX, chartY + chartH);
              ctx.lineTo(chartX + chartW, chartY + chartH);
              ctx.stroke();

              ctx.fillStyle = '#7f8c8d';
              ctx.font = '12px serif';
              ctx.textAlign = 'right';
              ctx.fillText('rank', chartX - 5, chartY + 5);

              const maxRank = Math.max(...groups.map(g => g.rank), 1);
              const barScale = chartH * 0.8 / maxRank;

              groups.forEach((g, i) => {
                const x = chartX + 15 + i * (barW + 8);
                const barH = g.rank * barScale;

                if (g.rank > 0) {
                  const pulse = 0.6 + 0.2 * Math.sin(t * 2 + i);
                  const colors = ['rgba(46,204,113,', 'rgba(52,152,219,', 'rgba(231,76,60,', 'rgba(155,89,182,', 'rgba(241,196,15,', 'rgba(230,126,34,'];
                  const colIdx = g.deg % colors.length;

                  ctx.fillStyle = colors[colIdx] + pulse + ')';
                  ctx.fillRect(x, chartY + chartH - barH, barW, barH);

                  ctx.strokeStyle = colors[colIdx] + '0.8)';
                  ctx.lineWidth = 1.5;
                  ctx.strokeRect(x, chartY + chartH - barH, barW, barH);

                  ctx.fillStyle = '#2c3e50';
                  ctx.font = 'bold 14px serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(g.rank === 1 ? '\u2124' : '\u2124' + sup(g.rank), x + barW / 2, chartY + chartH - barH - 8);
                }

                ctx.fillStyle = '#2c3e50';
                ctx.font = '13px serif';
                ctx.textAlign = 'center';
                ctx.fillText('H' + sub(g.deg), x + barW / 2, chartY + chartH + 18);
              });

              if (viz.state.showPoincare) {
                const polyY = height - 55;
                ctx.fillStyle = 'rgba(44, 62, 80, 0.05)';
                ctx.fillRect(15, polyY - 5, width - 30, 50);
                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.strokeRect(15, polyY - 5, width - 30, 50);

                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px serif';
                ctx.textAlign = 'center';

                let poly = 'P(t) = (1 + t' + sup(n) + ')(1 + t' + sup(m) + ') = ';
                let terms = [];
                for (const g of groups) {
                  if (g.rank > 0) {
                    if (g.deg === 0) terms.push('' + g.rank);
                    else terms.push((g.rank > 1 ? g.rank : '') + 't' + (g.deg > 1 ? sup(g.deg) : ''));
                  }
                }
                poly += terms.join(' + ');

                ctx.fillText(poly, width / 2, polyY + 14);

                let euler = 0;
                for (const g of groups) euler += (g.deg % 2 === 0 ? 1 : -1) * g.rank;
                ctx.fillText('\u03C7(S' + sup(n) + ' \u00D7 S' + sup(m) + ') = ' + euler, width / 2, polyY + 35);
              }
            },
            controls: [
              {
                type: 'slider',
                label: 'n (dim of first sphere)',
                min: 1,
                max: 5,
                step: 1,
                initial: 1,
                action: (viz, value) => { viz.state.n = value; }
              },
              {
                type: 'slider',
                label: 'm (dim of second sphere)',
                min: 1,
                max: 5,
                step: 1,
                initial: 1,
                action: (viz, value) => { viz.state.m = value; }
              }
            ]
          }
        }
      ],
      exercises: [
        {
          id: 'examples-ex1',
          question: 'Compute \\(H_*(T^3; \\mathbb{Z})\\) where \\(T^3 = S^1 \\times S^1 \\times S^1\\). Verify that \\(\\text{rank}(H_k) = \\binom{3}{k}\\).',
          hint: 'Use Künneth twice: first compute \\(H_*(T^2)\\) from \\(S^1 \\times S^1\\), then compute \\(H_*(T^2 \\times S^1)\\). All groups are free, so Tor = 0 throughout.',
          solution: `Step 1: \\(H_*(T^2) = (\\mathbb{Z}, \\mathbb{Z}^2, \\mathbb{Z})\\) (already computed).

Step 2: Apply Künneth to \\(T^3 = T^2 \\times S^1\\). Since all groups are free:
\\[H_n(T^3) = \\bigoplus_{p+q=n} H_p(T^2) \\otimes H_q(S^1)\\]

\\[H_0 = H_0(T^2) \\otimes H_0(S^1) = \\mathbb{Z}\\]
\\[H_1 = (H_1(T^2) \\otimes H_0(S^1)) \\oplus (H_0(T^2) \\otimes H_1(S^1)) = \\mathbb{Z}^2 \\oplus \\mathbb{Z} = \\mathbb{Z}^3\\]
\\[H_2 = (H_2(T^2) \\otimes H_0(S^1)) \\oplus (H_1(T^2) \\otimes H_1(S^1)) = \\mathbb{Z} \\oplus \\mathbb{Z}^2 = \\mathbb{Z}^3\\]
\\[H_3 = H_2(T^2) \\otimes H_1(S^1) = \\mathbb{Z}\\]

Ranks: \\(1, 3, 3, 1 = \\binom{3}{0}, \\binom{3}{1}, \\binom{3}{2}, \\binom{3}{3}\\). \\(\\checkmark\\)

The Poincare polynomial is \\((1+t)^3 = 1 + 3t + 3t^2 + t^3\\).`
        },
        {
          id: 'examples-ex2',
          question: 'Show that \\(S^2 \\times S^4\\) and \\(\\mathbb{C}P^3\\) have the same integral homology groups but are not homotopy equivalent, by computing their cohomology rings.',
          hint: 'Both have \\(H_0 = H_2 = H_4 = H_6 = \\mathbb{Z}\\) and all other groups zero. But the cup product structure is different: in \\(H^*(\\mathbb{C}P^3)\\), the generator of \\(H^2\\) squares to the generator of \\(H^4\\).',
          solution: `Homology groups:
\\[H_*(S^2 \\times S^4) = (\\mathbb{Z}, 0, \\mathbb{Z}, 0, \\mathbb{Z}, 0, \\mathbb{Z}) \\quad \\text{(by K\\"{u}nneth)}\\]
\\[H_*(\\mathbb{C}P^3) = (\\mathbb{Z}, 0, \\mathbb{Z}, 0, \\mathbb{Z}, 0, \\mathbb{Z}) \\quad \\text{(known)}\\]

These are identical. But the cohomology rings differ:

\\(S^2 \\times S^4\\): By Künneth, \\(H^* = \\Lambda[\\alpha] \\otimes \\Lambda[\\beta]\\) with \\(\\deg(\\alpha) = 2, \\deg(\\beta) = 4\\).
\\[\\alpha^2 = 0, \\quad \\beta^2 = 0, \\quad \\alpha\\beta \\text{ generates } H^6\\]

\\(\\mathbb{C}P^3\\): \\(H^* = \\mathbb{Z}[\\gamma]/(\\gamma^4)\\) with \\(\\deg(\\gamma) = 2\\).
\\[\\gamma^2 \\neq 0 \\text{ generates } H^4, \\quad \\gamma^3 \\text{ generates } H^6\\]

The key difference: in \\(S^2 \\times S^4\\), the square of the degree-2 generator is zero (\\(\\alpha^2 = 0\\)). In \\(\\mathbb{C}P^3\\), the square is nonzero (\\(\\gamma^2 \\neq 0\\)). Since a homotopy equivalence must preserve the ring structure, \\(S^2 \\times S^4 \\not\\simeq \\mathbb{C}P^3\\). \\(\\checkmark\\)`
        },
        {
          id: 'examples-ex3',
          question: 'Use the Poincare series to find the Betti numbers of \\(S^2 \\times S^2 \\times S^2\\).',
          hint: 'Compute \\(P(t) = (1 + t^2)^3\\) and expand.',
          solution: `The Poincare series of \\(S^2\\) is \\(P_{S^2}(t) = 1 + t^2\\).

By Künneth multiplicativity:
\\[P_{(S^2)^3}(t) = (1 + t^2)^3 = 1 + 3t^2 + 3t^4 + t^6\\]

Reading off the coefficients:
\\(b_0 = 1\\): one connected component.
\\(b_1 = 0\\): no 1-dimensional holes.
\\(b_2 = 3\\): three independent 2-spheres (one from each factor).
\\(b_3 = 0\\): no 3-dimensional holes.
\\(b_4 = 3\\): three independent 4-cycles (products of pairs).
\\(b_5 = 0\\): no 5-dimensional holes.
\\(b_6 = 1\\): the fundamental class of the 6-manifold.

Euler characteristic: \\(\\chi = 1 - 0 + 3 - 0 + 3 - 0 + 1 = 8 = 2^3 = \\chi(S^2)^3\\). \\(\\square\\)`
        }
      ]
    }
  ]
});
