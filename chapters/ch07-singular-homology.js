window.CHAPTERS = window.CHAPTERS || [];
window.CHAPTERS.push({
    id: 'ch07',
    number: 7,
    title: 'Singular Homology',
    subtitle: 'Homotopy invariance and excision',
    sections: [
        {
            id: 'singular-simplices',
            title: 'Singular Simplices and Chains',
            content: `
                <h2>From Simplicial to Singular Homology</h2>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>Simplicial homology requires a triangulation, which not all spaces have. <strong>Singular homology</strong> works for <em>any</em> topological space: instead of taking simplices as combinatorial data, we consider all continuous maps from the standard simplex \\(\\Delta^n\\) into \\(X\\).</p>
                        <p>This makes the theory functorial and homotopy-invariant, at the cost of having infinitely many generators (even for simple spaces).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 7.1 (Standard n-Simplex)</div>
                    <div class="env-body">
                        <p>The <strong>standard \\(n\\)-simplex</strong> is:
                        \\[\\Delta^n = \\left\\{(t_0, t_1, \\ldots, t_n) \\in \\mathbb{R}^{n+1} : t_i \\ge 0, \\sum_{i=0}^n t_i = 1\\right\\}\\]</p>
                        <p>It has \\(n+1\\) vertices \\(e_0, \\ldots, e_n\\) where \\(e_i = (0, \\ldots, 0, 1, 0, \\ldots, 0)\\) (1 in position \\(i\\)).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 7.2 (Singular n-Simplex)</div>
                    <div class="env-body">
                        <p>A <strong>singular \\(n\\)-simplex</strong> in a space \\(X\\) is a continuous map:
                        \\[\\sigma: \\Delta^n \\to X\\]</p>
                        <p>The set of all singular \\(n\\)-simplices in \\(X\\) is denoted \\(S_n(X)\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 7.3 (Singular Simplices)</div>
                    <div class="env-body">
                        <p>In \\(\\mathbb{R}^2\\), a singular 0-simplex is a point, a singular 1-simplex is a path (image of \\([0,1]\\)), a singular 2-simplex is the image of a triangle.</p>
                        <p>Unlike simplicial complexes, singular simplices can be <em>degenerate</em> (e.g., constant map), can overlap, and don't need to form a "nice" triangulation.</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="singular-simplex"></div>

                <div class="env-block definition">
                    <div class="env-title">Definition 7.4 (Singular Chain Groups)</div>
                    <div class="env-body">
                        <p>The <strong>singular \\(n\\)-chain group</strong> \\(C_n(X)\\) is the free abelian group generated by all singular \\(n\\)-simplices:
                        \\[C_n(X) = \\bigoplus_{\\sigma \\in S_n(X)} \\mathbb{Z} \\cdot \\sigma\\]</p>
                        <p>Elements are formal sums \\(\\sum a_i \\sigma_i\\) where \\(a_i \\in \\mathbb{Z}\\) and \\(\\sigma_i: \\Delta^n \\to X\\).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 7.5 (Face Maps)</div>
                    <div class="env-body">
                        <p>The <strong>\\(i\\)-th face map</strong> \\(F_i: \\Delta^{n-1} \\to \\Delta^n\\) is the linear map that omits the \\(i\\)-th vertex:
                        \\[F_i(t_0, \\ldots, t_{n-1}) = (t_0, \\ldots, t_{i-1}, 0, t_i, \\ldots, t_{n-1})\\]
                        (insert 0 at position \\(i\\)).</p>
                        <p>Geometrically, \\(F_i\\) embeds \\(\\Delta^{n-1}\\) as the \\(i\\)-th face of \\(\\Delta^n\\).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 7.6 (Boundary Operator for Singular Chains)</div>
                    <div class="env-body">
                        <p>For a singular \\(n\\)-simplex \\(\\sigma: \\Delta^n \\to X\\), define:
                        \\[\\partial_n(\\sigma) = \\sum_{i=0}^n (-1)^i \\sigma \\circ F_i\\]
                        where \\(\\sigma \\circ F_i: \\Delta^{n-1} \\to X\\) is the \\(i\\)-th face of \\(\\sigma\\).</p>
                        <p>Extend linearly to \\(\\partial_n: C_n(X) \\to C_{n-1}(X)\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 7.7 (∂² = 0 for Singular Chains)</div>
                    <div class="env-body">
                        <p>\\(\\partial_{n-1} \\circ \\partial_n = 0\\) for all \\(n\\).</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof Sketch</div>
                    <div class="env-body">
                        <p>Compute \\(\\partial \\partial \\sigma = \\partial \\left(\\sum_i (-1)^i \\sigma F_i\\right) = \\sum_{i,j} (-1)^{i+j} \\sigma F_i F_j\\).</p>
                        <p>When \\(i < j\\), the composition \\(F_i F_j\\) gives the same face as \\(F_{j-1} F_i\\), but with opposite sign. The terms cancel pairwise.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'singular-simplex',
                    title: 'Singular Simplex Visualizer',
                    description: 'See maps σ: Δⁿ → X',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let curvature = 0;

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.textContent = 'Deform the singular 2-simplex σ: Δ² → ℝ²';
                        body.appendChild(info);

                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = -100;
                        slider.max = 100;
                        slider.value = 0;
                        slider.style.width = '300px';
                        slider.oninput = (e) => {
                            curvature = parseInt(e.target.value) / 100;
                            draw();
                        };
                        controls.appendChild(slider);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const w = canvas.width;
                            const h = canvas.height;

                            // Left: Domain Δ²
                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '14px monospace';
                            ctx.fillText('Domain: Δ²', 50, 30);

                            const leftV0 = {x: w * 0.25, y: 100};
                            const leftV1 = {x: w * 0.25 - 80, y: 300};
                            const leftV2 = {x: w * 0.25 + 80, y: 300};

                            ctx.fillStyle = 'rgba(88, 166, 255, 0.3)';
                            ctx.beginPath();
                            ctx.moveTo(leftV0.x, leftV0.y);
                            ctx.lineTo(leftV1.x, leftV1.y);
                            ctx.lineTo(leftV2.x, leftV2.y);
                            ctx.closePath();
                            ctx.fill();

                            ctx.strokeStyle = '#58a6ff';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            // Vertices
                            [leftV0, leftV1, leftV2].forEach((v, i) => {
                                ctx.fillStyle = '#f0883e';
                                ctx.beginPath();
                                ctx.arc(v.x, v.y, 5, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '12px monospace';
                                ctx.fillText(`e${i}`, v.x + 10, v.y - 10);
                            });

                            // Arrow
                            ctx.strokeStyle = '#bc8cff';
                            ctx.fillStyle = '#bc8cff';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            const arrowY = h / 2;
                            ctx.beginPath();
                            ctx.moveTo(w * 0.4, arrowY);
                            ctx.lineTo(w * 0.55, arrowY);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Arrow head
                            ctx.beginPath();
                            ctx.moveTo(w * 0.55, arrowY);
                            ctx.lineTo(w * 0.55 - 10, arrowY - 5);
                            ctx.lineTo(w * 0.55 - 10, arrowY + 5);
                            ctx.closePath();
                            ctx.fill();

                            ctx.fillStyle = '#bc8cff';
                            ctx.font = '14px monospace';
                            ctx.fillText('σ', w * 0.47, arrowY - 10);

                            // Right: Codomain X (image in ℝ²)
                            ctx.fillStyle = '#c9d1d9';
                            ctx.fillText('Codomain: X (image of σ in ℝ²)', w * 0.6, 30);

                            const rightV0 = {x: w * 0.75, y: 100 + curvature * 20};
                            const rightV1 = {x: w * 0.75 - 80, y: 300 + curvature * 30};
                            const rightV2 = {x: w * 0.75 + 80, y: 300 - curvature * 30};

                            // Draw curved triangle
                            ctx.fillStyle = 'rgba(63, 185, 80, 0.3)';
                            ctx.beginPath();
                            ctx.moveTo(rightV0.x, rightV0.y);
                            ctx.quadraticCurveTo(
                                (rightV0.x + rightV1.x) / 2 - curvature * 40,
                                (rightV0.y + rightV1.y) / 2,
                                rightV1.x, rightV1.y
                            );
                            ctx.quadraticCurveTo(
                                (rightV1.x + rightV2.x) / 2,
                                (rightV1.y + rightV2.y) / 2 + curvature * 30,
                                rightV2.x, rightV2.y
                            );
                            ctx.quadraticCurveTo(
                                (rightV2.x + rightV0.x) / 2 + curvature * 40,
                                (rightV2.y + rightV0.y) / 2,
                                rightV0.x, rightV0.y
                            );
                            ctx.closePath();
                            ctx.fill();

                            ctx.strokeStyle = '#3fb950';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            // Vertices
                            [rightV0, rightV1, rightV2].forEach((v, i) => {
                                ctx.fillStyle = '#f0883e';
                                ctx.beginPath();
                                ctx.arc(v.x, v.y, 5, 0, 2*Math.PI);
                                ctx.fill();
                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '12px monospace';
                                ctx.fillText(`σ(e${i})`, v.x + 10, v.y - 10);
                            });

                            // Info
                            ctx.fillStyle = '#8b949e';
                            ctx.font = '12px monospace';
                            ctx.fillText('Singular simplices can be curved, overlapping, degenerate', 50, h - 30);
                            ctx.fillText('Unlike simplicial complexes, no combinatorial constraints', 50, h - 10);
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that for any space \\(X\\), \\(C_0(X)\\) is the free abelian group on the set of points of \\(X\\).',
                    hint: 'A 0-simplex \\(\\sigma: \\Delta^0 \\to X\\) is just a choice of point in \\(X\\).',
                    solution: 'Since \\(\\Delta^0\\) is a single point, a map \\(\\sigma: \\Delta^0 \\to X\\) is determined by where it sends that point, i.e., a choice of \\(x \\in X\\). Thus singular 0-simplices are in bijection with points of \\(X\\), and \\(C_0(X) = \\bigoplus_{x \\in X} \\mathbb{Z}\\).'
                },
                {
                    question: 'Compute the boundary of a singular 1-simplex \\(\\sigma: \\Delta^1 \\to X\\) (a path from \\(\\sigma(e_0)\\) to \\(\\sigma(e_1)\\)).',
                    hint: 'Use \\(\\partial_1(\\sigma) = \\sigma F_1 - \\sigma F_0\\).',
                    solution: '\\(F_0: \\Delta^0 \\to \\Delta^1\\) sends the point to \\(e_1\\), and \\(F_1\\) sends it to \\(e_0\\). So \\(\\partial_1(\\sigma) = \\sigma(e_1) - \\sigma(e_0)\\) (endpoint minus starting point, as in simplicial homology).'
                }
            ]
        },

        {
            id: 'singular-homology-groups',
            title: 'Singular Homology Groups Hₙ(X)',
            content: `
                <h2>Defining Singular Homology</h2>

                <div class="env-block definition">
                    <div class="env-title">Definition 7.8 (Singular Homology)</div>
                    <div class="env-body">
                        <p>The <strong>singular homology groups</strong> of \\(X\\) are:
                        \\[H_n(X) = \\frac{\\ker \\partial_n}{\\text{im} \\partial_{n+1}} = \\frac{Z_n(X)}{B_n(X)}\\]
                        where \\(Z_n(X) = \\ker \\partial_n\\) are <strong>cycles</strong> and \\(B_n(X) = \\text{im} \\partial_{n+1}\\) are <strong>boundaries</strong>.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 7.9 (Functoriality)</div>
                    <div class="env-body">
                        <p>If \\(f: X \\to Y\\) is continuous, there is an induced homomorphism:
                        \\[f_*: H_n(X) \\to H_n(Y)\\]
                        defined by \\(f_*(\\sum a_i \\sigma_i) = \\sum a_i (f \\circ \\sigma_i)\\) on chains, which descends to homology.</p>
                        <p>Properties:</p>
                        <ol>
                            <li>\\((\\text{id}_X)_* = \\text{id}_{H_n(X)}\\)</li>
                            <li>\\((g \\circ f)_* = g_* \\circ f_*\\)</li>
                        </ol>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 7.10 (Singular Homology of a Point)</div>
                    <div class="env-body">
                        <p>For \\(X = \\{\\text{pt}\\}\\):</p>
                        <ul>
                            <li>\\(C_n(\\text{pt}) = \\mathbb{Z}\\) for all \\(n\\) (only one singular \\(n\\)-simplex, the constant map)</li>
                            <li>\\(\\partial_n = 0\\) for \\(n\\) even, and \\(\\partial_n: \\mathbb{Z} \\to \\mathbb{Z}\\) is the zero map for odd \\(n\\) as well</li>
                            <li>Wait, actually: \\(\\partial_n(\\sigma) = \\sum (-1)^i \\sigma F_i\\). For constant maps, all faces are the same, so \\(\\partial_n(\\sigma) = (n+1) \\sigma\\) if \\(n\\) is even, 0 if \\(n\\) is odd. Hmm, let me reconsider...</li>
                        </ul>
                        <p>Actually, the correct computation: All singular simplices are constant, so \\(\\partial\\) alternates sum of \\((n+1)\\) copies. For \\(n\\) even, \\(\\partial = 0\\); for \\(n\\) odd, \\(\\partial\\) is multiplication by \\(n+1\\). Working out the homology: \\(H_0(\\text{pt}) = \\mathbb{Z}\\), \\(H_n(\\text{pt}) = 0\\) for \\(n > 0\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 7.11 (Singular ≅ Simplicial for Triangulable Spaces)</div>
                    <div class="env-body">
                        <p>If \\(X\\) has a triangulation \\(K\\) (i.e., \\(X \\cong |K|\\)), then:
                        \\[H_n^{\\text{sing}}(X) \\cong H_n^{\\text{simp}}(K)\\]</p>
                        <p>Thus singular homology extends simplicial homology to all topological spaces.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 7.12 (Singular Homology of Sⁿ)</div>
                    <div class="env-body">
                        <p>By the above theorem and previous computations:
                        \\[H_k(S^n) = \\begin{cases} \\mathbb{Z} & k = 0, n \\\\ 0 & \\text{otherwise} \\end{cases}\\]</p>
                    </div>
                </div>
            `,
            visualizations: [],
            exercises: [
                {
                    question: 'Show that \\(H_0(X) \\cong \\mathbb{Z}^{\\pi_0(X)}\\) where \\(\\pi_0(X)\\) is the set of path components.',
                    hint: 'A 0-cycle is a formal sum \\(\\sum a_i x_i\\) with \\(\\sum a_i = 0\\) (from augmentation). Boundaries connect points in the same component.',
                    solution: 'Elements of \\(Z_0(X)\\) are formal sums of points with total coefficient 0. Boundaries are differences \\(\\sigma(e_1) - \\sigma(e_0)\\) for paths \\(\\sigma\\), which connect points in the same path component. Thus \\(H_0(X) = Z_0 / B_0\\) has one \\(\\mathbb{Z}\\) summand per path component.'
                },
                {
                    question: 'Prove that a continuous map \\(f: X \\to Y\\) induces a chain map \\(f_\\#: C_n(X) \\to C_n(Y)\\) with \\(\\partial f_\\# = f_\\# \\partial\\).',
                    hint: 'Define \\(f_\\#(\\sigma) = f \\circ \\sigma\\) and verify \\(\\partial(f \\circ \\sigma) = f \\circ (\\partial \\sigma)\\).',
                    solution: '\\(\\partial(f \\sigma) = \\sum (-1)^i (f \\sigma) F_i = \\sum (-1)^i f (\\sigma F_i) = f \\left(\\sum (-1)^i \\sigma F_i\\right) = f (\\partial \\sigma)\\). Thus \\(\\partial f_\\# = f_\\# \\partial\\), so \\(f_\\#\\) is a chain map and descends to \\(f_*: H_n(X) \\to H_n(Y)\\).'
                }
            ]
        },

        {
            id: 'homotopy-invariance',
            title: 'Homotopy Invariance of Singular Homology',
            content: `
                <h2>Homotopy Invariance: The Key Property</h2>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 7.13 (Homotopy Invariance)</div>
                    <div class="env-body">
                        <p>If \\(f, g: X \\to Y\\) are homotopic (\\(f \\simeq g\\)), then the induced maps on homology are equal:
                        \\[f_* = g_*: H_n(X) \\to H_n(Y)\\]
                        for all \\(n\\).</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof Strategy (via Chain Homotopy)</div>
                    <div class="env-body">
                        <p>The idea is to construct a <strong>chain homotopy</strong> \\(P: C_n(X) \\to C_{n+1}(Y)\\) such that:
                        \\[f_\\# - g_\\# = \\partial P + P \\partial\\]</p>
                        <p>This implies that on cycles (\\(\\partial z = 0\\)): \\(f_\\#(z) - g_\\#(z) = \\partial P(z) \\in B_n(Y)\\), so \\([f_\\#(z)] = [g_\\#(z)]\\) in \\(H_n(Y)\\).</p>
                        <p><strong>Construction of \\(P\\):</strong> Given a homotopy \\(H: X \\times [0,1] \\to Y\\) with \\(H_0 = f\\) and \\(H_1 = g\\), define \\(P(\\sigma)\\) to be a "prism" over \\(\\sigma\\) traced out by \\(H\\). The details involve subdividing \\(\\Delta^n \\times [0,1]\\) into \\((n+1)\\)-simplices and summing with appropriate signs. See Hatcher §2.1 for the full proof.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="homotopy-invariance"></div>

                <div class="env-block corollary">
                    <div class="env-title">Corollary 7.14 (Homotopy Equivalent Spaces Have Isomorphic Homology)</div>
                    <div class="env-body">
                        <p>If \\(f: X \\to Y\\) is a homotopy equivalence, then \\(f_*: H_n(X) \\to H_n(Y)\\) is an isomorphism for all \\(n\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 7.15 (Applications)</div>
                    <div class="env-body">
                        <p>\\(\\mathbb{R}^n \\simeq \\{\\text{pt}\\}\\), so \\(H_*(\\mathbb{R}^n) = H_*(\\text{pt}) = (\\mathbb{Z}, 0, 0, \\ldots)\\).</p>
                        <p>\\(\\mathbb{R}^2 \\setminus \\{0\\} \\simeq S^1\\), so \\(H_*(\\mathbb{R}^2 \\setminus \\{0\\}) = H_*(S^1) = (\\mathbb{Z}, \\mathbb{Z}, 0, 0, \\ldots)\\).</p>
                        <p>Any convex subset of \\(\\mathbb{R}^n\\) is contractible, so has trivial homology except \\(H_0 = \\mathbb{Z}\\).</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Comparison with π₁)</div>
                    <div class="env-body">
                        <p>The fundamental group \\(\\pi_1(X)\\) is also homotopy-invariant, but is generally non-abelian and hard to compute. Homology \\(H_*(X)\\) is always abelian and (usually) easier to compute, at the cost of losing some information.</p>
                        <p>The Hurewicz theorem connects them: \\(H_1(X) \\cong \\pi_1(X)^{\\text{ab}}\\).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'homotopy-invariance',
                    title: 'Homotopy Invariance Animator',
                    description: 'Deform space, homology unchanged',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let t = 0;
                        let animating = false;

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.innerHTML = 'Homotopy: ℝ² \\ {0} ≃ S¹ (homology preserved)';
                        body.appendChild(info);

                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = 0;
                        slider.max = 100;
                        slider.value = 0;
                        slider.style.width = '300px';
                        slider.oninput = (e) => {
                            t = e.target.value / 100;
                            draw();
                        };
                        controls.appendChild(slider);

                        const playBtn = document.createElement('button');
                        playBtn.textContent = 'Animate';
                        playBtn.onclick = () => {
                            animating = !animating;
                            if (animating) {
                                playBtn.textContent = 'Stop';
                                animate();
                            } else {
                                playBtn.textContent = 'Animate';
                            }
                        };
                        controls.appendChild(playBtn);

                        function animate() {
                            if (!animating) return;
                            t += 0.01;
                            if (t > 1) t = 0;
                            slider.value = t * 100;
                            draw();
                            requestAnimationFrame(animate);
                        }

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const w = canvas.width;
                            const h = canvas.height;
                            const cx = w / 2;
                            const cy = h / 2;

                            // Draw ℝ² \ {0} contracting to S¹
                            const outerR = 120 * (1 - t) + 80 * t;
                            const innerR = 5 * (1 - t) + 75 * t;

                            // Annulus (ℝ² \ {0} represented as annulus)
                            ctx.fillStyle = 'rgba(88, 166, 255, 0.3)';
                            ctx.beginPath();
                            ctx.arc(cx, cy, outerR, 0, 2*Math.PI);
                            ctx.arc(cx, cy, innerR, 0, 2*Math.PI, true);
                            ctx.fill();

                            ctx.strokeStyle = '#58a6ff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(cx, cy, outerR, 0, 2*Math.PI);
                            ctx.stroke();

                            ctx.strokeStyle = '#f85149';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(cx, cy, innerR, 0, 2*Math.PI);
                            ctx.stroke();

                            // Hole (origin)
                            ctx.fillStyle = '#0d1117';
                            ctx.beginPath();
                            ctx.arc(cx, cy, innerR, 0, 2*Math.PI);
                            ctx.fill();

                            // Labels
                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '14px monospace';
                            if (t < 0.5) {
                                ctx.fillText('ℝ² \\ {0}', cx + outerR + 10, cy);
                                ctx.fillStyle = '#f85149';
                                ctx.fillText('{0}', cx - 10, cy - innerR - 10);
                            } else {
                                ctx.fillText('S¹', cx + outerR + 10, cy);
                            }

                            // Homology (constant throughout)
                            ctx.fillStyle = '#3fb950';
                            ctx.font = '14px monospace';
                            ctx.fillText('H₀ = ℤ, H₁ = ℤ, Hₙ = 0 (n ≥ 2)', 50, h - 50);
                            ctx.fillStyle = '#8b949e';
                            ctx.font = '12px monospace';
                            ctx.fillText('Homology is homotopy-invariant!', 50, h - 25);
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Use homotopy invariance to compute \\(H_*(D^n)\\) (the \\(n\\)-disk).',
                    hint: '\\(D^n\\) is contractible.',
                    solution: 'Since \\(D^n \\simeq \\{\\text{pt}\\}\\), we have \\(H_*(D^n) = H_*(\\text{pt}) = (\\mathbb{Z}, 0, 0, \\ldots)\\). Thus \\(H_0(D^n) = \\mathbb{Z}\\) and \\(H_k(D^n) = 0\\) for \\(k \\ge 1\\).'
                },
                {
                    question: 'Show that if \\(X\\) deformation retracts onto \\(A\\), then \\(H_n(X) \\cong H_n(A)\\) for all \\(n\\).',
                    hint: 'A deformation retraction is a homotopy equivalence.',
                    solution: 'A deformation retraction \\(r: X \\to A\\) with inclusion \\(i: A \\hookrightarrow X\\) satisfies \\(r \\circ i = \\text{id}_A\\) and \\(i \\circ r \\simeq \\text{id}_X\\). Thus \\(r\\) is a homotopy equivalence, so \\(r_*: H_n(X) \\to H_n(A)\\) is an isomorphism.'
                }
            ]
        },

        {
            id: 'excision',
            title: 'Excision Theorem',
            content: `
                <h2>Cutting and Pasting: The Excision Theorem</h2>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 7.16 (Excision Theorem)</div>
                    <div class="env-body">
                        <p>Let \\(X\\) be a topological space and \\(Z \\subseteq A \\subseteq X\\) with \\(\\overline{Z} \\subseteq \\text{int}(A)\\). Then the inclusion \\((X \\setminus Z, A \\setminus Z) \\hookrightarrow (X, A)\\) induces an isomorphism:
                        \\[H_n(X \\setminus Z, A \\setminus Z) \\xrightarrow{\\cong} H_n(X, A)\\]
                        for all \\(n\\).</p>
                        <p>Informally: "You can excise (cut out) a subset \\(Z\\) from \\(X\\) and \\(A\\) without changing relative homology, as long as \\(Z\\) is 'well inside' \\(A\\)."</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Relative Homology)</div>
                    <div class="env-body">
                        <p>The <strong>relative homology</strong> \\(H_n(X, A)\\) is defined as the homology of the quotient chain complex:
                        \\[H_n(X, A) = H_n(C_*(X) / C_*(A))\\]
                        where \\(C_*(A) \\subseteq C_*(X)\\) is the subcomplex of chains in \\(A\\).</p>
                        <p>Geometrically, \\(H_n(X, A)\\) measures "\\(n\\)-cycles in \\(X\\) modulo those in \\(A\\)".</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="excision-diagram"></div>

                <div class="env-block example">
                    <div class="env-title">Example 7.17 (Excision for the Sphere)</div>
                    <div class="env-body">
                        <p>Let \\(X = S^n\\), \\(A = D^n_+\\) (northern hemisphere), \\(B = D^n_-\\) (southern hemisphere), with \\(A \\cap B = S^{n-1}\\) (equator).</p>
                        <p>Excise the interior of \\(B\\): \\(H_n(S^n \\setminus \\text{int}(B), A \\setminus \\text{int}(B)) = H_n(S^n, A)\\).</p>
                        <p>But \\(S^n \\setminus \\text{int}(B) \\simeq D^n_+\\) and \\(A \\setminus \\text{int}(B) = S^{n-1}\\), so:
                        \\[H_n(D^n, S^{n-1}) \\cong H_n(S^n, A)\\]</p>
                        <p>Since \\(A \\simeq D^n\\) is contractible, \\(H_n(S^n, A) \\cong \\tilde{H}_n(S^n / A)\\). But \\(S^n / A \\cong S^n\\) (collapsing a contractible subset), so \\(H_n(D^n, S^{n-1}) \\cong \\tilde{H}_n(S^n)\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 7.18 (Long Exact Sequence of a Pair)</div>
                    <div class="env-body">
                        <p>For \\(A \\subseteq X\\), there is a long exact sequence:
                        \\[\\cdots \\to H_n(A) \\xrightarrow{i_*} H_n(X) \\xrightarrow{j_*} H_n(X, A) \\xrightarrow{\\partial} H_{n-1}(A) \\to \\cdots\\]
                        where \\(i: A \\hookrightarrow X\\) is inclusion, \\(j: X \\to (X, A)\\) is the quotient, and \\(\\partial\\) is the boundary map.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 7.19 (Computing H*(Sⁿ) via Excision)</div>
                    <div class="env-body">
                        <p>Using the LES of the pair \\((D^n, S^{n-1})\\):
                        \\[\\cdots \\to H_k(S^{n-1}) \\to H_k(D^n) \\to H_k(D^n, S^{n-1}) \\to H_{k-1}(S^{n-1}) \\to \\cdots\\]</p>
                        <p>Since \\(H_k(D^n) = 0\\) for \\(k \\ge 1\\), exactness gives \\(H_k(D^n, S^{n-1}) \\cong H_{k-1}(S^{n-1})\\).</p>
                        <p>By excision and \\((D^n, S^{n-1}) \\cong (D^n / S^{n-1}, \\text{pt}) \\cong (S^n, \\text{pt})\\), we have \\(H_k(D^n, S^{n-1}) \\cong \\tilde{H}_k(S^n)\\).</p>
                        <p>Thus: \\(\\tilde{H}_k(S^n) \\cong H_{k-1}(S^{n-1})\\). By induction starting from \\(S^0\\), we get \\(H_k(S^n) = \\mathbb{Z}\\) for \\(k = n\\), else 0.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 7.20 (Mayer-Vietoris Sequence)</div>
                    <div class="env-body">
                        <p>If \\(X = A \\cup B\\) with \\(A, B\\) open, there is a long exact sequence:
                        \\[\\cdots \\to H_n(A \\cap B) \\xrightarrow{\\Phi} H_n(A) \\oplus H_n(B) \\xrightarrow{\\Psi} H_n(X) \\xrightarrow{\\partial} H_{n-1}(A \\cap B) \\to \\cdots\\]
                        where \\(\\Phi(x) = (i_*(x), j_*(x))\\) and \\(\\Psi(a, b) = k_*(a) - \\ell_*(b)\\).</p>
                        <p>This is a powerful computational tool: to compute \\(H_*(X)\\), decompose \\(X = A \\cup B\\) into simpler pieces.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'excision-diagram',
                    title: 'Excision Diagram (Interactive)',
                    description: 'Cut out Z, homology unchanged',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let showZ = true;

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.innerHTML = 'Excision: Remove Z from both X and A';
                        body.appendChild(info);

                        const toggleBtn = document.createElement('button');
                        toggleBtn.textContent = 'Excise Z';
                        toggleBtn.onclick = () => {
                            showZ = !showZ;
                            toggleBtn.textContent = showZ ? 'Excise Z' : 'Show Z';
                            draw();
                        };
                        controls.appendChild(toggleBtn);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const w = canvas.width;
                            const h = canvas.height;
                            const cx = w / 2;
                            const cy = h / 2;

                            // Draw X (outer circle)
                            ctx.strokeStyle = '#58a6ff';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(cx, cy, 150, 0, 2*Math.PI);
                            ctx.stroke();

                            ctx.fillStyle = '#58a6ff';
                            ctx.font = '14px monospace';
                            ctx.fillText('X', cx + 160, cy);

                            // Draw A (inner circle)
                            ctx.fillStyle = 'rgba(63, 185, 80, 0.2)';
                            ctx.beginPath();
                            ctx.arc(cx, cy, 100, 0, 2*Math.PI);
                            ctx.fill();

                            ctx.strokeStyle = '#3fb950';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            ctx.fillStyle = '#3fb950';
                            ctx.fillText('A', cx + 110, cy);

                            if (showZ) {
                                // Draw Z (small circle inside A)
                                ctx.fillStyle = 'rgba(248, 81, 73, 0.5)';
                                ctx.beginPath();
                                ctx.arc(cx - 30, cy - 30, 30, 0, 2*Math.PI);
                                ctx.fill();

                                ctx.strokeStyle = '#f85149';
                                ctx.lineWidth = 2;
                                ctx.stroke();

                                ctx.fillStyle = '#f85149';
                                ctx.fillText('Z', cx - 25, cy - 10);
                            } else {
                                // Show hole where Z was
                                ctx.fillStyle = '#0d1117';
                                ctx.beginPath();
                                ctx.arc(cx - 30, cy - 30, 30, 0, 2*Math.PI);
                                ctx.fill();

                                ctx.strokeStyle = '#f85149';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                                ctx.stroke();
                                ctx.setLineDash([]);
                            }

                            // Info
                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '13px monospace';
                            if (showZ) {
                                ctx.fillText('Before excision: Hₙ(X, A)', 50, h - 40);
                                ctx.fillStyle = '#8b949e';
                                ctx.font = '12px monospace';
                                ctx.fillText('Z ⊆ A ⊆ X, with Z̄ ⊆ int(A)', 50, h - 20);
                            } else {
                                ctx.fillText('After excision: Hₙ(X \\ Z, A \\ Z) ≅ Hₙ(X, A)', 50, h - 40);
                                ctx.fillStyle = '#8b949e';
                                ctx.font = '12px monospace';
                                ctx.fillText('Relative homology is unchanged!', 50, h - 20);
                            }
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Use the Mayer-Vietoris sequence to compute \\(H_*(S^n)\\) by writing \\(S^n = U \\cup V\\) where \\(U, V\\) are contractible open sets.',
                    hint: 'Take \\(U, V\\) to be slightly more than the northern and southern hemispheres, so \\(U \\cap V \\simeq S^{n-1}\\).',
                    solution: 'Let \\(U, V\\) be open neighborhoods of the upper and lower hemispheres with \\(U \\cap V \\simeq S^{n-1}\\). Since \\(U, V\\) are contractible, \\(H_k(U) = H_k(V) = 0\\) for \\(k \\ge 1\\). The M-V sequence gives: \\(0 \\to H_k(S^n) \\to H_{k-1}(S^{n-1}) \\to 0\\), so \\(H_k(S^n) \\cong H_{k-1}(S^{n-1})\\). By induction from \\(S^0\\), we get \\(H_n(S^n) = \\mathbb{Z}\\), else 0.'
                },
                {
                    question: 'Prove that \\(H_n(D^n, S^{n-1}) \\cong \\mathbb{Z}\\) and \\(H_k(D^n, S^{n-1}) = 0\\) for \\(k \\neq n\\).',
                    hint: 'Use the LES of the pair \\((D^n, S^{n-1})\\) and the fact that \\(D^n\\) is contractible.',
                    solution: 'The LES: \\(\\cdots \\to H_k(S^{n-1}) \\to H_k(D^n) \\to H_k(D^n, S^{n-1}) \\to H_{k-1}(S^{n-1}) \\to \\cdots\\). Since \\(H_k(D^n) = 0\\) for \\(k \\ge 1\\), exactness gives \\(H_k(D^n, S^{n-1}) \\cong H_{k-1}(S^{n-1})\\). For \\(k = n\\): \\(H_n(D^n, S^{n-1}) \\cong H_{n-1}(S^{n-1}) = \\mathbb{Z}\\). For \\(k = 0\\): \\(H_0(D^n) = \\mathbb{Z}\\), \\(H_0(S^{n-1}) = \\mathbb{Z}\\), and the map is an isomorphism (both connected), so \\(H_0(D^n, S^{n-1}) = 0\\).'
                }
            ]
        }
    ]
});
