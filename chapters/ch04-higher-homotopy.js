window.CHAPTERS = window.CHAPTERS || [];
window.CHAPTERS.push({
    id: 'ch04',
    number: 4,
    title: 'Higher Homotopy Groups',
    subtitle: 'πₙ(X, x₀) and fibration sequences',
    sections: [
        {
            id: 'higher-homotopy-def',
            title: 'Definition of πₙ(X, x₀)',
            content: `
                <h2>Higher Homotopy Groups</h2>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>The fundamental group \\(\\pi_1(X, x_0)\\) measures loops in \\(X\\). Higher homotopy groups \\(\\pi_n(X, x_0)\\) measure maps from higher-dimensional spheres \\(S^n\\) into \\(X\\). They detect "holes" of different dimensions.</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 4.1 (n-Sphere Sⁿ)</div>
                    <div class="env-body">
                        <p>The <strong>\\(n\\)-sphere</strong> is \\(S^n = \\{x \\in \\mathbb{R}^{n+1} : |x| = 1\\}\\).</p>
                        <p>Equivalently, \\(S^n = I^n / \\partial I^n\\), the \\(n\\)-cube with its boundary collapsed to a point.</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 4.2 (Higher Homotopy Groups)</div>
                    <div class="env-body">
                        <p>For \\(n \\ge 1\\), the <strong>\\(n\\)-th homotopy group</strong> \\(\\pi_n(X, x_0)\\) is the set of homotopy classes of pointed maps \\(f: (S^n, s_0) \\to (X, x_0)\\), where \\(s_0 \\in S^n\\) is a basepoint.</p>
                        <p>Two maps \\(f, g: (S^n, s_0) \\to (X, x_0)\\) are <strong>homotopic</strong> (\\(f \\simeq g\\)) if there exists a continuous \\(H: S^n \\times [0,1] \\to X\\) with:</p>
                        <ul>
                            <li>\\(H(x, 0) = f(x)\\) and \\(H(x, 1) = g(x)\\) for all \\(x \\in S^n\\)</li>
                            <li>\\(H(s_0, t) = x_0\\) for all \\(t \\in [0,1]\\) (basepoint fixed)</li>
                        </ul>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 4.3 (Group Operation on πₙ)</div>
                    <div class="env-body">
                        <p>For \\(n \\ge 1\\), define the sum \\([f] + [g]\\) by identifying \\(S^n = I^n / \\partial I^n\\) and setting:
                        \\[(f + g)(t_1, t_2, \\ldots, t_n) = \\begin{cases} f(2t_1, t_2, \\ldots, t_n) & 0 \\le t_1 \\le 1/2 \\\\ g(2t_1 - 1, t_2, \\ldots, t_n) & 1/2 \\le t_1 \\le 1 \\end{cases}\\]
                        (Glue along the first coordinate.)</p>
                        <p>This makes \\(\\pi_n(X, x_0)\\) a group for \\(n \\ge 1\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="higher-homotopy-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 4.4 (πₙ is Abelian for n ≥ 2)</div>
                    <div class="env-body">
                        <p>For \\(n \\ge 2\\), the group \\(\\pi_n(X, x_0)\\) is <strong>abelian</strong>.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof Sketch</div>
                    <div class="env-body">
                        <p>For \\(n = 1\\), commutativity fails in general (e.g., \\(\\pi_1(S^1 \\vee S^1)\\) is the free group on two generators, non-abelian).</p>
                        <p>For \\(n \\ge 2\\), we can "slide" one map past another using two coordinates. The Eckmann-Hilton argument shows \\([f] + [g] = [g] + [f]\\) because we can deform the "pinch map" along two independent directions in \\(S^n\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 4.5 (Homotopy Groups of Spheres)</div>
                    <div class="env-body">
                        <p>\\(\\pi_n(S^n) \\cong \\mathbb{Z}\\), generated by the identity map \\(\\text{id}_{S^n}: S^n \\to S^n\\).</p>
                        <p>\\(\\pi_k(S^n) = 0\\) for \\(k < n\\) (by cellular approximation).</p>
                        <p>For \\(k > n\\), computing \\(\\pi_k(S^n)\\) is extremely difficult! For instance:</p>
                        <ul>
                            <li>\\(\\pi_3(S^2) \\cong \\mathbb{Z}\\) (Hopf fibration)</li>
                            <li>\\(\\pi_4(S^3) \\cong \\mathbb{Z}/2\\mathbb{Z}\\)</li>
                            <li>\\(\\pi_{15}(S^1) \\cong \\mathbb{Z}/2\\mathbb{Z}\\) (!!)</li>
                        </ul>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Comparison with Homology)</div>
                    <div class="env-body">
                        <p>Unlike \\(\\pi_n\\), homology groups \\(H_n(X)\\) are much easier to compute and are always abelian. The <strong>Hurewicz theorem</strong> (next chapter) connects them: under good conditions, \\(H_n(X) \\cong \\pi_n(X)^{\\text{ab}}\\).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'higher-homotopy-viz',
                    title: 'Higher Homotopy Visualizer (π₂(S²))',
                    description: 'Visualize maps from S² to S² and their homotopy classes',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let degree = 1;

                        const label = document.createElement('div');
                        label.style.marginTop = '10px';
                        label.style.color = '#c9d1d9';
                        label.textContent = `Map degree: ${degree} (element of π₂(S²) ≅ ℤ)`;
                        body.appendChild(label);

                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = -3;
                        slider.max = 3;
                        slider.value = degree;
                        slider.style.width = '300px';
                        slider.oninput = (e) => {
                            degree = parseInt(e.target.value);
                            label.textContent = `Map degree: ${degree} (element of π₂(S²) ≅ ℤ)`;
                            draw();
                        };
                        controls.appendChild(slider);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const w = canvas.width;
                            const h = canvas.height;

                            // Draw domain sphere S² (left)
                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '14px monospace';
                            ctx.fillText('Domain: S²', 50, 30);

                            const leftCX = w * 0.25;
                            const leftCY = h / 2;
                            const radius = 80;

                            // Draw sphere as circle (equator)
                            ctx.strokeStyle = '#58a6ff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(leftCX, leftCY, radius, 0, 2 * Math.PI);
                            ctx.stroke();

                            // Draw latitude lines
                            ctx.globalAlpha = 0.3;
                            for (let lat = -0.6; lat <= 0.6; lat += 0.3) {
                                const r = radius * Math.cos(Math.asin(lat));
                                const y = leftCY - radius * lat;
                                ctx.beginPath();
                                ctx.ellipse(leftCX, y, r, r * 0.3, 0, 0, 2 * Math.PI);
                                ctx.stroke();
                            }
                            ctx.globalAlpha = 1.0;

                            // Basepoint
                            ctx.fillStyle = '#f0883e';
                            ctx.beginPath();
                            ctx.arc(leftCX + radius, leftCY, 6, 0, 2*Math.PI);
                            ctx.fill();
                            ctx.fillStyle = '#c9d1d9';
                            ctx.fillText('s₀', leftCX + radius + 10, leftCY + 5);

                            // Draw codomain sphere S² (right)
                            ctx.fillText('Codomain: S²', w * 0.65, 30);

                            const rightCX = w * 0.75;
                            const rightCY = h / 2;

                            ctx.strokeStyle = '#3fb950';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(rightCX, rightCY, radius, 0, 2 * Math.PI);
                            ctx.stroke();

                            // Draw latitude lines
                            ctx.globalAlpha = 0.3;
                            for (let lat = -0.6; lat <= 0.6; lat += 0.3) {
                                const r = radius * Math.cos(Math.asin(lat));
                                const y = rightCY - radius * lat;
                                ctx.beginPath();
                                ctx.ellipse(rightCX, y, r, r * 0.3, 0, 0, 2 * Math.PI);
                                ctx.stroke();
                            }
                            ctx.globalAlpha = 1.0;

                            // Basepoint
                            ctx.fillStyle = '#f0883e';
                            ctx.beginPath();
                            ctx.arc(rightCX + radius, rightCY, 6, 0, 2*Math.PI);
                            ctx.fill();
                            ctx.fillStyle = '#c9d1d9';
                            ctx.fillText('x₀', rightCX + radius + 10, rightCY + 5);

                            // Draw mapping arrow
                            ctx.strokeStyle = '#bc8cff';
                            ctx.fillStyle = '#bc8cff';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(leftCX + radius + 15, leftCY - 30);
                            ctx.lineTo(rightCX - radius - 15, rightCY - 30);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Arrow head
                            ctx.beginPath();
                            ctx.moveTo(rightCX - radius - 15, rightCY - 30);
                            ctx.lineTo(rightCX - radius - 25, rightCY - 35);
                            ctx.lineTo(rightCX - radius - 25, rightCY - 25);
                            ctx.closePath();
                            ctx.fill();

                            ctx.fillStyle = '#bc8cff';
                            ctx.font = '14px monospace';
                            ctx.fillText(`f: S² → S² (deg ${degree})`, w/2 - 60, leftCY - 50);

                            // Info box
                            ctx.fillStyle = '#8b949e';
                            ctx.font = '12px monospace';
                            ctx.fillText('π₂(S²) ≅ ℤ, generated by id_S²', 20, h - 40);
                            ctx.fillText(`This map wraps S² around itself ${Math.abs(degree)} time(s)`, 20, h - 20);
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that \\(\\pi_1(S^n) = 0\\) for \\(n \\ge 2\\).',
                    hint: 'Any loop in \\(S^n\\) (\\(n \\ge 2\\)) misses at least one point. The complement is contractible.',
                    solution: 'Let \\(\\gamma: S^1 \\to S^n\\) be a loop. Since \\(\\dim S^1 = 1 < n\\), the image \\(\\gamma(S^1)\\) has measure zero and misses some point \\(p \\in S^n\\). Then \\(S^n \\setminus \\{p\\} \\cong \\mathbb{R}^n\\) is contractible, so \\(\\gamma\\) is null-homotopic.'
                },
                {
                    question: 'Prove that \\(\\pi_n(X \\times Y, (x_0, y_0)) \\cong \\pi_n(X, x_0) \\times \\pi_n(Y, y_0)\\).',
                    hint: 'A map \\(S^n \\to X \\times Y\\) is the same as a pair of maps \\(S^n \\to X\\) and \\(S^n \\to Y\\).',
                    solution: 'Define \\(\\Phi: \\pi_n(X \\times Y) \\to \\pi_n(X) \\times \\pi_n(Y)\\) by \\(\\Phi([f]) = ([\\pi_X \\circ f], [\\pi_Y \\circ f])\\), where \\(\\pi_X, \\pi_Y\\) are projections. The inverse is \\(\\Psi([g], [h]) = [(g, h)]\\). Both are group homomorphisms.'
                }
            ]
        },

        {
            id: 'fibration-les',
            title: 'Long Exact Sequence of a Fibration',
            content: `
                <h2>Fibrations and the Long Exact Sequence</h2>

                <div class="env-block definition">
                    <div class="env-title">Definition 4.6 (Fibration)</div>
                    <div class="env-body">
                        <p>A map \\(p: E \\to B\\) is a <strong>fibration</strong> if it has the <strong>homotopy lifting property</strong>: for any space \\(X\\) and homotopy \\(H: X \\times [0,1] \\to B\\) with a lift \\(\\tilde{H}_0: X \\to E\\) at \\(t=0\\) (i.e., \\(p \\circ \\tilde{H}_0 = H_0\\)), there exists a lift \\(\\tilde{H}: X \\times [0,1] \\to E\\) with \\(p \\circ \\tilde{H} = H\\) and \\(\\tilde{H}|_{t=0} = \\tilde{H}_0\\).</p>
                        <p>The space \\(E\\) is the <strong>total space</strong>, \\(B\\) is the <strong>base space</strong>, and \\(F = p^{-1}(b_0)\\) is the <strong>fiber</strong>.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 4.7 (Covering Maps are Fibrations)</div>
                    <div class="env-body">
                        <p>The universal covering \\(p: \\mathbb{R} \\to S^1\\), \\(p(t) = e^{2\\pi i t}\\), is a fibration with fiber \\(\\mathbb{Z}\\) (discrete).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 4.8 (Hopf Fibration)</div>
                    <div class="env-body">
                        <p>The <strong>Hopf fibration</strong> \\(S^3 \\to S^2\\) with fiber \\(S^1\\) is given by viewing \\(S^3 \\subset \\mathbb{C}^2\\) and mapping \\((z_1, z_2) \\mapsto [z_1 : z_2] \\in \\mathbb{CP}^1 \\cong S^2\\).</p>
                        <p>This shows \\(\\pi_3(S^2) \\cong \\mathbb{Z}\\) (non-zero!).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="fibration-les"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 4.9 (Long Exact Sequence of a Fibration)</div>
                    <div class="env-body">
                        <p>Given a fibration \\(F \\to E \\xrightarrow{p} B\\) with basepoints, there is a <strong>long exact sequence</strong>:
                        \\[\\cdots \\to \\pi_n(F) \\xrightarrow{i_*} \\pi_n(E) \\xrightarrow{p_*} \\pi_n(B) \\xrightarrow{\\partial} \\pi_{n-1}(F) \\to \\cdots \\to \\pi_0(F) \\to \\pi_0(E) \\to \\pi_0(B)\\]
                        where \\(i: F \\hookrightarrow E\\) is the inclusion and \\(\\partial\\) is the <strong>boundary map</strong>.</p>
                        <p><strong>Exactness</strong> means \\(\\ker(p_*) = \\text{im}(i_*)\\), \\(\\ker(\\partial) = \\text{im}(p_*)\\), etc.</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Boundary Map ∂)</div>
                    <div class="env-body">
                        <p>The boundary map \\(\\partial: \\pi_n(B, b_0) \\to \\pi_{n-1}(F, f_0)\\) is defined as follows: given \\([\\alpha] \\in \\pi_n(B)\\), lift \\(\\alpha|_{\\partial I^n}\\) (the boundary) to \\(E\\), which lands in \\(F\\) since \\(\\alpha(\\partial I^n) = b_0\\). This gives an element of \\(\\pi_{n-1}(F)\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 4.10 (LES of S¹ → S¹)</div>
                    <div class="env-body">
                        <p>For the covering \\(\\mathbb{R} \\to S^1\\) (fiber = \\(\\mathbb{Z}\\) discrete), we have:
                        \\[\\cdots \\to \\pi_1(\\mathbb{Z}) \\to \\pi_1(\\mathbb{R}) \\to \\pi_1(S^1) \\xrightarrow{\\partial} \\pi_0(\\mathbb{Z}) \\to \\pi_0(\\mathbb{R}) \\to \\pi_0(S^1)\\]
                        Since \\(\\pi_1(\\mathbb{R}) = 0\\) and \\(\\pi_1(S^1) = \\mathbb{Z}\\), exactness gives \\(\\pi_0(\\mathbb{Z}) \\cong \\mathbb{Z}\\) (each integer is a component).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'fibration-les',
                    title: 'Fibration Sequence Diagram',
                    description: 'Interactive long exact sequence viewer',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 350;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let highlightIndex = -1;

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.textContent = 'Click on groups to highlight exactness: ker = im';
                        body.appendChild(info);

                        const sequence = [
                            {label: '⋯', type: 'dots'},
                            {label: 'π₂(F)', type: 'group', level: 2},
                            {label: 'π₂(E)', type: 'group', level: 2},
                            {label: 'π₂(B)', type: 'group', level: 2},
                            {label: 'π₁(F)', type: 'group', level: 1},
                            {label: 'π₁(E)', type: 'group', level: 1},
                            {label: 'π₁(B)', type: 'group', level: 1},
                            {label: 'π₀(F)', type: 'group', level: 0},
                            {label: 'π₀(E)', type: 'group', level: 0},
                            {label: 'π₀(B)', type: 'group', level: 0}
                        ];

                        const arrows = ['', 'i*', 'p*', '∂', 'i*', 'p*', '∂', 'i*', 'p*'];

                        canvas.addEventListener('click', (e) => {
                            const rect = canvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;

                            const boxWidth = 70;
                            const spacing = 85;
                            const startX = 30;

                            for (let i = 0; i < sequence.length; i++) {
                                const posX = startX + i * spacing;
                                const posY = 150;
                                if (x >= posX && x <= posX + boxWidth && y >= posY - 20 && y <= posY + 20) {
                                    highlightIndex = i;
                                    draw();
                                    return;
                                }
                            }
                        });

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);

                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '14px monospace';
                            ctx.fillText('Long Exact Sequence: F → E → B', 20, 30);

                            const boxWidth = 70;
                            const boxHeight = 40;
                            const spacing = 85;
                            const startX = 30;
                            const y = 150;

                            // Draw sequence
                            for (let i = 0; i < sequence.length; i++) {
                                const item = sequence[i];
                                const x = startX + i * spacing;

                                if (item.type === 'dots') {
                                    ctx.fillStyle = '#8b949e';
                                    ctx.font = '18px monospace';
                                    ctx.fillText(item.label, x, y);
                                } else {
                                    // Draw box
                                    ctx.strokeStyle = i === highlightIndex ? '#f0883e' : '#58a6ff';
                                    ctx.lineWidth = i === highlightIndex ? 3 : 2;
                                    ctx.strokeRect(x, y - 20, boxWidth, boxHeight);

                                    // Draw label
                                    ctx.fillStyle = i === highlightIndex ? '#f0883e' : '#c9d1d9';
                                    ctx.font = '13px monospace';
                                    ctx.fillText(item.label, x + 10, y + 5);

                                    // Draw level indicator
                                    ctx.fillStyle = '#8b949e';
                                    ctx.font = '10px monospace';
                                    ctx.fillText(`n=${item.level}`, x + 15, y - 25);
                                }

                                // Draw arrows
                                if (i < sequence.length - 1 && i > 0) {
                                    ctx.strokeStyle = '#3fb950';
                                    ctx.fillStyle = '#3fb950';
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.moveTo(x + boxWidth + 2, y);
                                    ctx.lineTo(x + spacing - 2, y);
                                    ctx.stroke();

                                    // Arrow head
                                    ctx.beginPath();
                                    ctx.moveTo(x + spacing - 2, y);
                                    ctx.lineTo(x + spacing - 8, y - 4);
                                    ctx.lineTo(x + spacing - 8, y + 4);
                                    ctx.closePath();
                                    ctx.fill();

                                    // Arrow label
                                    ctx.fillStyle = '#3fb950';
                                    ctx.font = '11px monospace';
                                    ctx.fillText(arrows[i], x + boxWidth + 5, y - 5);
                                }
                            }

                            // Exactness info
                            if (highlightIndex >= 1 && highlightIndex < sequence.length) {
                                ctx.fillStyle = '#f0883e';
                                ctx.font = '13px monospace';
                                const item = sequence[highlightIndex];
                                ctx.fillText(`Exactness at ${item.label}: ker(outgoing) = im(incoming)`, 30, canvas.height - 30);
                            }

                            // Legend
                            ctx.fillStyle = '#8b949e';
                            ctx.font = '11px monospace';
                            ctx.fillText('Exact: composition of consecutive maps is zero', 30, canvas.height - 10);
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Use the LES of the Hopf fibration \\(S^1 \\to S^3 \\to S^2\\) to compute \\(\\pi_3(S^2)\\).',
                    hint: 'We know \\(\\pi_3(S^3) \\cong \\mathbb{Z}\\), \\(\\pi_2(S^2) \\cong \\mathbb{Z}\\), \\(\\pi_2(S^3) = 0\\), \\(\\pi_3(S^1) = 0\\).',
                    solution: 'The LES gives: \\(\\pi_3(S^1) \\to \\pi_3(S^3) \\to \\pi_3(S^2) \\to \\pi_2(S^1)\\), i.e., \\(0 \\to \\mathbb{Z} \\to \\pi_3(S^2) \\to 0\\). By exactness, \\(\\pi_3(S^2) \\cong \\mathbb{Z}\\).'
                },
                {
                    question: 'Show that the long exact sequence is indeed exact at \\(\\pi_n(E)\\): \\(\\ker(p_*) = \\text{im}(i_*)\\).',
                    hint: 'If \\([\\alpha] \\in \\ker(p_*)\\), then \\(p \\circ \\alpha \\simeq \\text{const}\\). Lift this homotopy to show \\(\\alpha\\) factors through \\(F\\).',
                    solution: 'Clearly \\(\\text{im}(i_*) \\subseteq \\ker(p_*)\\) since \\(p \\circ i\\) is constant on \\(F\\). Conversely, if \\(p_*([\\alpha]) = 0\\), use the homotopy lifting property to show \\(\\alpha \\simeq i \\circ \\beta\\) for some \\(\\beta: S^n \\to F\\). Details in Hatcher §4.2.'
                }
            ]
        },

        {
            id: 'whitehead-hurewicz',
            title: 'Whitehead and Hurewicz Theorems',
            content: `
                <h2>Connecting Homotopy and Homology</h2>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 4.11 (Whitehead's Theorem)</div>
                    <div class="env-body">
                        <p>Let \\(f: X \\to Y\\) be a map between CW complexes. If \\(f_*: \\pi_n(X, x_0) \\to \\pi_n(Y, f(x_0))\\) is an isomorphism for all \\(n \\ge 0\\), then \\(f\\) is a homotopy equivalence.</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Power of Whitehead's Theorem)</div>
                    <div class="env-body">
                        <p>This says: for CW complexes, \\(\\pi_*\\) is a <em>complete invariant</em> up to homotopy equivalence. If all homotopy groups match, the spaces are homotopy equivalent!</p>
                        <p>However, computing \\(\\pi_n\\) is hard. Homology \\(H_n\\) is easier, but does not determine homotopy type (e.g., \\(S^2 \\vee S^3\\) and \\(S^2 \\times S^3\\) have the same homology but different homotopy groups).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 4.12 (Hurewicz Theorem - Preview)</div>
                    <div class="env-body">
                        <p>Let \\(X\\) be a path-connected space. There is a natural homomorphism:
                        \\[h: \\pi_n(X, x_0) \\to H_n(X)\\]
                        called the <strong>Hurewicz map</strong>.</p>
                        <p><strong>Special case (n = 1):</strong> If \\(X\\) is path-connected, then
                        \\[h: \\pi_1(X, x_0) \\to H_1(X)\\]
                        is surjective with kernel equal to the commutator subgroup \\([\\pi_1, \\pi_1]\\). Hence:
                        \\[H_1(X) \\cong \\pi_1(X)^{\\text{ab}} = \\pi_1(X) / [\\pi_1, \\pi_1]\\]
                        (abelianization).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 4.13 (H₁ from π₁)</div>
                    <div class="env-body">
                        <p>For \\(X = S^1\\), we have \\(\\pi_1(S^1) \\cong \\mathbb{Z}\\) (already abelian), so \\(H_1(S^1) \\cong \\mathbb{Z}\\).</p>
                        <p>For the torus \\(T^2 = S^1 \\times S^1\\), \\(\\pi_1(T^2) \\cong \\mathbb{Z} \\times \\mathbb{Z}\\), so \\(H_1(T^2) \\cong \\mathbb{Z}^2\\).</p>
                        <p>For the figure-eight \\(S^1 \\vee S^1\\), \\(\\pi_1(S^1 \\vee S^1) \\cong F_2\\) (free group on two generators, non-abelian). The abelianization \\(F_2^{\\text{ab}} \\cong \\mathbb{Z}^2\\), so \\(H_1(S^1 \\vee S^1) \\cong \\mathbb{Z}^2\\).</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Full Hurewicz Theorem)</div>
                    <div class="env-body">
                        <p>In general, if \\(X\\) is \\((n-1)\\)-connected (i.e., \\(\\pi_i(X) = 0\\) for \\(i < n\\)), then:
                        \\[h: \\pi_n(X) \\xrightarrow{\\cong} H_n(X)\\]
                        is an isomorphism.</p>
                        <p>For example, \\(S^n\\) is \\((n-1)\\)-connected, so \\(\\pi_n(S^n) \\cong H_n(S^n) \\cong \\mathbb{Z}\\).</p>
                        <p>We will prove the full Hurewicz theorem after developing homology theory in Chapters 5-7.</p>
                    </div>
                </div>
            `,
            visualizations: [],
            exercises: [
                {
                    question: 'Use the Hurewicz theorem (n=1 case) to compute \\(H_1(\\mathbb{RP}^2)\\).',
                    hint: 'We know \\(\\pi_1(\\mathbb{RP}^2) \\cong \\mathbb{Z}/2\\mathbb{Z}\\).',
                    solution: 'Since \\(\\mathbb{RP}^2\\) is path-connected, \\(H_1(\\mathbb{RP}^2) \\cong \\pi_1(\\mathbb{RP}^2)^{\\text{ab}} \\cong (\\mathbb{Z}/2\\mathbb{Z})^{\\text{ab}} \\cong \\mathbb{Z}/2\\mathbb{Z}\\) (already abelian).'
                },
                {
                    question: 'Show that \\(S^2 \\vee S^3\\) and \\(S^2 \\times S^3\\) have the same homology groups but are not homotopy equivalent.',
                    hint: 'Compute \\(\\pi_*\\) and \\(H_*\\) for both spaces.',
                    solution: 'Both have \\(H_0 = \\mathbb{Z}\\), \\(H_1 = 0\\), \\(H_2 = \\mathbb{Z}\\), \\(H_3 = \\mathbb{Z}\\), \\(H_n = 0\\) for \\(n \\ge 4\\). However, \\(\\pi_2(S^2 \\vee S^3) \\cong \\mathbb{Z}\\) but \\(\\pi_2(S^2 \\times S^3) \\cong \\mathbb{Z} \\times 0 \\cong \\mathbb{Z}\\), so they match in \\(\\pi_2\\). The key difference is \\(\\pi_5(S^2 \\vee S^3) \\neq \\pi_5(S^2 \\times S^3)\\) due to the Whitehead product. By Whitehead\'s theorem, they are not homotopy equivalent.'
                }
            ]
        }
    ]
});
