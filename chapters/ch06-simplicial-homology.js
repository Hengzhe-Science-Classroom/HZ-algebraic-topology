window.CHAPTERS = window.CHAPTERS || [];
window.CHAPTERS.push({
    id: 'ch06',
    number: 6,
    title: 'Simplicial Homology',
    subtitle: 'Chain complexes and Hₙ = Ker ∂ / Im ∂',
    sections: [
        {
            id: 'chain-groups',
            title: 'Chain Groups and Boundary Operator',
            content: `
                <h2>The Algebraic Machinery of Homology</h2>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>Homology measures "holes" of different dimensions. The idea: take formal sums of simplices (chains), define a boundary operator ∂, and study cycles (∂ = 0) modulo boundaries (things that are themselves ∂ of something).</p>
                        <p>The homology groups \\(H_n = Z_n / B_n = \\ker \\partial_n / \\text{im} \\partial_{n+1}\\) detect \\(n\\)-dimensional holes.</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.1 (Chain Groups)</div>
                    <div class="env-body">
                        <p>Let \\(K\\) be a simplicial complex. The <strong>\\(n\\)-th chain group</strong> \\(C_n(K)\\) is the free abelian group generated by the \\(n\\)-simplices of \\(K\\):</p>
                        <p>\\[C_n(K) = \\left\\{\\sum_{\\sigma \\in K_n} a_\\sigma \\sigma : a_\\sigma \\in \\mathbb{Z}\\right\\}\\]</p>
                        <p>Elements of \\(C_n(K)\\) are called <strong>\\(n\\)-chains</strong> (formal integer linear combinations of \\(n\\)-simplices).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.2 (Chains in a Triangle)</div>
                    <div class="env-body">
                        <p>For the filled triangle \\(K = \\Delta^2\\) with vertices \\(\\{0, 1, 2\\}\\):</p>
                        <ul>
                            <li>\\(C_0(K) \\cong \\mathbb{Z}^3\\) (basis: \\(\\{0\\}, \\{1\\}, \\{2\\}\\))</li>
                            <li>\\(C_1(K) \\cong \\mathbb{Z}^3\\) (basis: \\([0,1], [1,2], [0,2]\\))</li>
                            <li>\\(C_2(K) \\cong \\mathbb{Z}\\) (basis: \\([0,1,2]\\))</li>
                        </ul>
                        <p>A typical 1-chain: \\(3[0,1] - 2[1,2] + [0,2] \\in C_1(K)\\).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.3 (Boundary Operator ∂)</div>
                    <div class="env-body">
                        <p>The <strong>boundary operator</strong> \\(\\partial_n: C_n(K) \\to C_{n-1}(K)\\) is defined on a single \\(n\\)-simplex \\(\\sigma = [v_0, v_1, \\ldots, v_n]\\) by:</p>
                        <p>\\[\\partial_n(\\sigma) = \\sum_{i=0}^n (-1)^i [v_0, \\ldots, \\hat{v}_i, \\ldots, v_n]\\]</p>
                        <p>(where \\(\\hat{v}_i\\) means omit \\(v_i\\)).</p>
                        <p>Extend linearly to all of \\(C_n(K)\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="boundary-viz"></div>

                <div class="env-block example">
                    <div class="env-title">Example 6.4 (Boundary Computations)</div>
                    <div class="env-body">
                        <p>For a 1-simplex \\([v_0, v_1]\\): \\(\\partial_1([v_0, v_1]) = [v_1] - [v_0]\\).</p>
                        <p>For a 2-simplex \\([v_0, v_1, v_2]\\): \\(\\partial_2([v_0, v_1, v_2]) = [v_1, v_2] - [v_0, v_2] + [v_0, v_1]\\).</p>
                        <p>Check: \\(\\partial_1 \\circ \\partial_2([v_0, v_1, v_2]) = \\partial_1([v_1, v_2]) - \\partial_1([v_0, v_2]) + \\partial_1([v_0, v_1])\\)
                        \\[= ([v_2] - [v_1]) - ([v_2] - [v_0]) + ([v_1] - [v_0]) = 0\\]</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.5 (∂² = 0)</div>
                    <div class="env-body">
                        <p>\\(\\partial_{n-1} \\circ \\partial_n = 0\\) for all \\(n\\). In other words, the boundary of a boundary is zero.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>Compute \\(\\partial_{n-1} \\circ \\partial_n([v_0, \\ldots, v_n])\\):
                        \\[\\partial_{n-1}\\left(\\sum_{i=0}^n (-1)^i [v_0, \\ldots, \\hat{v}_i, \\ldots, v_n]\\right) = \\sum_{i=0}^n (-1)^i \\partial_{n-1}([v_0, \\ldots, \\hat{v}_i, \\ldots, v_n])\\]
                        \\[= \\sum_{i < j} (-1)^{i+j-1} [v_0, \\ldots, \\hat{v}_i, \\ldots, \\hat{v}_j, \\ldots, v_n] + \\sum_{i > j} (-1)^{i+j} [v_0, \\ldots, \\hat{v}_j, \\ldots, \\hat{v}_i, \\ldots, v_n]\\]</p>
                        <p>Each term appears twice with opposite signs, so they cancel.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.6 (Cycles and Boundaries)</div>
                    <div class="env-body">
                        <p>The <strong>group of \\(n\\)-cycles</strong> is \\(Z_n(K) = \\ker \\partial_n = \\{c \\in C_n : \\partial_n(c) = 0\\}\\).</p>
                        <p>The <strong>group of \\(n\\)-boundaries</strong> is \\(B_n(K) = \\text{im} \\partial_{n+1} = \\{\\partial_{n+1}(c) : c \\in C_{n+1}\\}\\).</p>
                        <p>Since \\(\\partial^2 = 0\\), we have \\(B_n \\subseteq Z_n\\) (every boundary is a cycle).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'boundary-viz',
                    title: 'Boundary Operator Visualizer',
                    description: 'Click simplices to see their boundaries',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let selectedSimplex = null;

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.innerHTML = 'Click on edges or triangles to see ∂';
                        body.appendChild(info);

                        // Define triangle
                        const v0 = {x: canvas.width/2, y: 80, label: 'v₀'};
                        const v1 = {x: canvas.width/2 - 100, y: 300, label: 'v₁'};
                        const v2 = {x: canvas.width/2 + 100, y: 300, label: 'v₂'};

                        const vertices = [v0, v1, v2];
                        const edges = [
                            {v: [v0, v1], label: '[v₀,v₁]', type: 'edge'},
                            {v: [v1, v2], label: '[v₁,v₂]', type: 'edge'},
                            {v: [v0, v2], label: '[v₀,v₂]', type: 'edge'}
                        ];
                        const triangle = {v: [v0, v1, v2], label: '[v₀,v₁,v₂]', type: 'triangle'};

                        canvas.addEventListener('click', (e) => {
                            const rect = canvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;

                            // Check if triangle clicked
                            const inTriangle = pointInTriangle(x, y, v0, v1, v2);
                            if (inTriangle) {
                                selectedSimplex = triangle;
                                info.innerHTML = `∂([v₀,v₁,v₂]) = <span style="color:#3fb950">[v₁,v₂]</span> - <span style="color:#f85149">[v₀,v₂]</span> + <span style="color:#58a6ff">[v₀,v₁]</span>`;
                                draw();
                                return;
                            }

                            // Check edges
                            for (let edge of edges) {
                                if (distToSegment(x, y, edge.v[0], edge.v[1]) < 10) {
                                    selectedSimplex = edge;
                                    const i0 = vertices.indexOf(edge.v[0]);
                                    const i1 = vertices.indexOf(edge.v[1]);
                                    info.innerHTML = `∂(${edge.label}) = ${edge.v[1].label} - ${edge.v[0].label}`;
                                    draw();
                                    return;
                                }
                            }

                            selectedSimplex = null;
                            info.innerHTML = 'Click on edges or triangles to see ∂';
                            draw();
                        });

                        function pointInTriangle(x, y, v0, v1, v2) {
                            const sign = (p1, p2, p3) => (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
                            const d1 = sign({x, y}, v0, v1);
                            const d2 = sign({x, y}, v1, v2);
                            const d3 = sign({x, y}, v2, v0);
                            const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);
                            const has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);
                            return !(has_neg && has_pos);
                        }

                        function distToSegment(x, y, v1, v2) {
                            const A = x - v1.x;
                            const B = y - v1.y;
                            const C = v2.x - v1.x;
                            const D = v2.y - v1.y;
                            const dot = A * C + B * D;
                            const len_sq = C * C + D * D;
                            let param = -1;
                            if (len_sq !== 0) param = dot / len_sq;
                            let xx, yy;
                            if (param < 0) {
                                xx = v1.x;
                                yy = v1.y;
                            } else if (param > 1) {
                                xx = v2.x;
                                yy = v2.y;
                            } else {
                                xx = v1.x + param * C;
                                yy = v1.y + param * D;
                            }
                            const dx = x - xx;
                            const dy = y - yy;
                            return Math.sqrt(dx * dx + dy * dy);
                        }

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);

                            // Draw triangle fill
                            if (selectedSimplex && selectedSimplex.type === 'triangle') {
                                ctx.fillStyle = 'rgba(88, 166, 255, 0.3)';
                                ctx.beginPath();
                                ctx.moveTo(v0.x, v0.y);
                                ctx.lineTo(v1.x, v1.y);
                                ctx.lineTo(v2.x, v2.y);
                                ctx.closePath();
                                ctx.fill();
                            }

                            // Draw edges
                            edges.forEach(edge => {
                                const isSelected = selectedSimplex && selectedSimplex.type === 'edge' && selectedSimplex.label === edge.label;
                                const isBoundaryPart = selectedSimplex && selectedSimplex.type === 'triangle';

                                if (isBoundaryPart) {
                                    // Color code boundary parts
                                    if (edge.label === '[v₁,v₂]') ctx.strokeStyle = '#3fb950';
                                    else if (edge.label === '[v₀,v₂]') ctx.strokeStyle = '#f85149';
                                    else ctx.strokeStyle = '#58a6ff';
                                    ctx.lineWidth = 4;
                                } else {
                                    ctx.strokeStyle = isSelected ? '#f0883e' : '#8b949e';
                                    ctx.lineWidth = isSelected ? 4 : 2;
                                }

                                ctx.beginPath();
                                ctx.moveTo(edge.v[0].x, edge.v[0].y);
                                ctx.lineTo(edge.v[1].x, edge.v[1].y);
                                ctx.stroke();
                            });

                            // Draw vertices
                            vertices.forEach(v => {
                                ctx.fillStyle = '#f0883e';
                                ctx.beginPath();
                                ctx.arc(v.x, v.y, 6, 0, 2*Math.PI);
                                ctx.fill();

                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '14px monospace';
                                ctx.fillText(v.label, v.x + 10, v.y - 10);
                            });

                            // Draw labels for edges
                            ctx.fillStyle = '#8b949e';
                            ctx.font = '12px monospace';
                            edges.forEach(edge => {
                                const mx = (edge.v[0].x + edge.v[1].x) / 2;
                                const my = (edge.v[0].y + edge.v[1].y) / 2;
                                // ctx.fillText(edge.label, mx - 30, my - 5);
                            });
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Verify that \\(\\partial_1 \\circ \\partial_2 = 0\\) for the 2-simplex \\([v_0, v_1, v_2]\\).',
                    hint: 'Compute \\(\\partial_2([v_0, v_1, v_2])\\) first, then apply \\(\\partial_1\\) to each edge.',
                    solution: '\\(\\partial_2([v_0, v_1, v_2]) = [v_1, v_2] - [v_0, v_2] + [v_0, v_1]\\). Then \\(\\partial_1([v_1, v_2]) = [v_2] - [v_1]\\), \\(\\partial_1([v_0, v_2]) = [v_2] - [v_0]\\), \\(\\partial_1([v_0, v_1]) = [v_1] - [v_0]\\). Sum: \\(([v_2] - [v_1]) - ([v_2] - [v_0]) + ([v_1] - [v_0]) = 0\\). ✓'
                },
                {
                    question: 'Show that \\(B_n(K) \\subseteq Z_n(K)\\).',
                    hint: 'Use \\(\\partial^2 = 0\\).',
                    solution: 'If \\(c \\in B_n(K)\\), then \\(c = \\partial_{n+1}(d)\\) for some \\(d \\in C_{n+1}\\). Apply \\(\\partial_n\\): \\(\\partial_n(c) = \\partial_n \\circ \\partial_{n+1}(d) = 0\\). Thus \\(c \\in Z_n(K)\\).'
                }
            ]
        },

        {
            id: 'homology-groups',
            title: 'Homology Groups Hₙ = Zₙ / Bₙ',
            content: `
                <h2>Defining Homology</h2>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.7 (Homology Groups)</div>
                    <div class="env-body">
                        <p>The <strong>\\(n\\)-th homology group</strong> of \\(K\\) is the quotient:
                        \\[H_n(K) = Z_n(K) / B_n(K) = \\frac{\\ker \\partial_n}{\\text{im} \\partial_{n+1}}\\]</p>
                        <p>Equivalently, \\(H_n(K)\\) is the set of \\(n\\)-cycles modulo \\(n\\)-boundaries.</p>
                        <p>Two cycles \\(z_1, z_2 \\in Z_n\\) are <strong>homologous</strong> (\\(z_1 \\sim z_2\\)) if \\(z_1 - z_2 \\in B_n\\).</p>
                    </div>
                </div>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>\\(H_n(K)\\) measures \\(n\\)-dimensional "holes":</p>
                        <ul>
                            <li>\\(H_0\\) counts connected components (minus 1)</li>
                            <li>\\(H_1\\) counts "loops" or "tunnels"</li>
                            <li>\\(H_2\\) counts "voids" or "cavities"</li>
                        </ul>
                        <p>A cycle is a chain with no boundary (∂c = 0). A boundary is a cycle that bounds something (c = ∂d). Homology asks: which cycles are <em>not</em> boundaries?</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="cycle-boundary"></div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.8 (Betti Numbers)</div>
                    <div class="env-body">
                        <p>The <strong>\\(n\\)-th Betti number</strong> \\(b_n(K)\\) is the rank of \\(H_n(K)\\) (as a free abelian group):
                        \\[b_n(K) = \\text{rank}(H_n(K))\\]</p>
                        <p>For finite simplicial complexes, \\(H_n(K)\\) is finitely generated, so \\(H_n(K) \\cong \\mathbb{Z}^{b_n} \\oplus T_n\\) where \\(T_n\\) is a finite torsion group.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.9 (Homology of a Point)</div>
                    <div class="env-body">
                        <p>For \\(K = \\{v\\}\\) (single vertex):</p>
                        <ul>
                            <li>\\(C_0 = \\mathbb{Z}\\), \\(C_n = 0\\) for \\(n \\ge 1\\)</li>
                            <li>\\(Z_0 = C_0 = \\mathbb{Z}\\), \\(B_0 = 0\\)</li>
                            <li>\\(H_0(K) = \\mathbb{Z}\\), \\(H_n(K) = 0\\) for \\(n \\ge 1\\)</li>
                        </ul>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.10 (Homology of S¹ - Hollow Triangle)</div>
                    <div class="env-body">
                        <p>For \\(K = S^1\\) (three vertices, three edges, no 2-simplex):</p>
                        <ul>
                            <li>\\(C_0 = \\mathbb{Z}^3\\), \\(C_1 = \\mathbb{Z}^3\\), \\(C_n = 0\\) for \\(n \\ge 2\\)</li>
                            <li>\\(\\partial_1: C_1 \\to C_0\\) has rank 2 (image is 2-dimensional subspace)</li>
                            <li>\\(\\ker \\partial_1 = \\mathbb{Z}\\) (the cycle \\([v_0, v_1] + [v_1, v_2] + [v_2, v_0]\\))</li>
                            <li>\\(B_1 = 0\\) (no 2-simplices, so \\(\\partial_2 = 0\\))</li>
                            <li>\\(H_1(K) = Z_1 / B_1 = \\mathbb{Z} / 0 = \\mathbb{Z}\\)</li>
                            <li>\\(H_0(K) = \\mathbb{Z}\\) (one component)</li>
                        </ul>
                        <p>Thus \\(H_0(S^1) = \\mathbb{Z}\\), \\(H_1(S^1) = \\mathbb{Z}\\), \\(H_n(S^1) = 0\\) for \\(n \\ge 2\\).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'cycle-boundary',
                    title: 'Cycle/Boundary Highlighter',
                    description: 'Mark cycles (green) vs boundaries (red)',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let mode = 'cycle'; // 'cycle' or 'boundary'

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.innerHTML = '<strong>Cycle</strong>: ∂c = 0 (green). <strong>Boundary</strong>: c = ∂d (red).';
                        body.appendChild(info);

                        const cycleBtn = document.createElement('button');
                        cycleBtn.textContent = 'Show Cycle';
                        cycleBtn.onclick = () => {
                            mode = 'cycle';
                            draw();
                        };
                        controls.appendChild(cycleBtn);

                        const boundaryBtn = document.createElement('button');
                        boundaryBtn.textContent = 'Show Boundary';
                        boundaryBtn.onclick = () => {
                            mode = 'boundary';
                            draw();
                        };
                        controls.appendChild(boundaryBtn);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const w = canvas.width;
                            const h = canvas.height;

                            if (mode === 'cycle') {
                                // Draw hollow triangle (1-cycle)
                                const v0 = {x: w/2, y: 100};
                                const v1 = {x: w/2 - 100, y: 300};
                                const v2 = {x: w/2 + 100, y: 300};

                                ctx.strokeStyle = '#3fb950';
                                ctx.lineWidth = 4;
                                ctx.beginPath();
                                ctx.moveTo(v0.x, v0.y);
                                ctx.lineTo(v1.x, v1.y);
                                ctx.lineTo(v2.x, v2.y);
                                ctx.closePath();
                                ctx.stroke();

                                // Vertices
                                [v0, v1, v2].forEach(v => {
                                    ctx.fillStyle = '#f0883e';
                                    ctx.beginPath();
                                    ctx.arc(v.x, v.y, 6, 0, 2*Math.PI);
                                    ctx.fill();
                                });

                                ctx.fillStyle = '#3fb950';
                                ctx.font = '14px monospace';
                                ctx.fillText('Cycle: ∂([v₀,v₁] + [v₁,v₂] + [v₂,v₀]) = 0', 50, 50);
                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '12px monospace';
                                ctx.fillText('This 1-cycle is not a boundary (no 2-simplex fills it)', 50, h - 30);
                                ctx.fillText('So it represents a nontrivial element of H₁(S¹) ≅ ℤ', 50, h - 10);

                            } else {
                                // Draw filled triangle (1-boundary)
                                const v0 = {x: w/2, y: 100};
                                const v1 = {x: w/2 - 100, y: 300};
                                const v2 = {x: w/2 + 100, y: 300};

                                ctx.fillStyle = 'rgba(248, 81, 73, 0.3)';
                                ctx.beginPath();
                                ctx.moveTo(v0.x, v0.y);
                                ctx.lineTo(v1.x, v1.y);
                                ctx.lineTo(v2.x, v2.y);
                                ctx.closePath();
                                ctx.fill();

                                ctx.strokeStyle = '#f85149';
                                ctx.lineWidth = 4;
                                ctx.stroke();

                                // Vertices
                                [v0, v1, v2].forEach(v => {
                                    ctx.fillStyle = '#f0883e';
                                    ctx.beginPath();
                                    ctx.arc(v.x, v.y, 6, 0, 2*Math.PI);
                                    ctx.fill();
                                });

                                ctx.fillStyle = '#f85149';
                                ctx.font = '14px monospace';
                                ctx.fillText('Boundary: ∂([v₀,v₁,v₂]) = [v₁,v₂] - [v₀,v₂] + [v₀,v₁]', 50, 50);
                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '12px monospace';
                                ctx.fillText('This 1-cycle IS a boundary (bounds the 2-simplex)', 50, h - 30);
                                ctx.fillText('So it represents 0 ∈ H₁(Δ²) (disk has no H₁)', 50, h - 10);
                            }
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Compute \\(H_*(\\Delta^2)\\) (the filled triangle).',
                    hint: 'The filled triangle is contractible.',
                    solution: 'We have \\(C_0 = \\mathbb{Z}^3\\), \\(C_1 = \\mathbb{Z}^3\\), \\(C_2 = \\mathbb{Z}\\). The boundary \\(\\partial_2([v_0, v_1, v_2]) = [v_1, v_2] - [v_0, v_2] + [v_0, v_1]\\) is a cycle that spans \\(Z_1\\). So \\(B_1 = Z_1\\), giving \\(H_1 = 0\\). Similarly, \\(H_0 = \\mathbb{Z}\\) (one component), \\(H_n = 0\\) for \\(n \\ge 2\\). Thus \\(H_*(\\Delta^2) = (\\mathbb{Z}, 0, 0, \\ldots)\\).'
                },
                {
                    question: 'Show that \\(H_0(K) \\cong \\mathbb{Z}^k\\) where \\(k\\) is the number of connected components of \\(|K|\\).',
                    hint: 'Consider \\(\\ker \\partial_0 = C_0\\) (all 0-chains are cycles) and \\(\\text{im} \\partial_1\\) (edges connect vertices).',
                    solution: '\\(Z_0 = C_0 = \\mathbb{Z}^{|V|}\\). \\(B_0 = \\text{im} \\partial_1\\) consists of sums \\(\\sum [v_i] - [v_j]\\) for edges \\([v_i, v_j]\\). These relations identify vertices within each component. Thus \\(H_0 = C_0 / B_0 \\cong \\mathbb{Z}^k\\) where \\(k\\) = number of components.'
                }
            ]
        },

        {
            id: 'computation-examples',
            title: 'Computation Examples: Spheres, Torus, ℝP²',
            content: `
                <h2>Computing Homology of Classic Spaces</h2>

                <div class="env-block example">
                    <div class="env-title">Example 6.11 (Homology of Sⁿ)</div>
                    <div class="env-body">
                        <p>For the \\(n\\)-sphere \\(S^n\\) (minimal triangulation: boundary of \\(\\Delta^{n+1}\\)):
                        \\[H_k(S^n) = \\begin{cases} \\mathbb{Z} & k = 0, n \\\\ 0 & \\text{otherwise} \\end{cases}\\]</p>
                        <p><strong>Proof sketch:</strong> Triangulate \\(S^n\\) as \\(\\partial \\Delta^{n+1}\\). The top cycle \\(\\sum_{i=0}^{n+1} (-1)^i [v_0, \\ldots, \\hat{v}_i, \\ldots, v_{n+1}]\\) generates \\(H_n(S^n) \\cong \\mathbb{Z}\\). It is not a boundary (no \\((n+1)\\)-simplex in \\(S^n\\)).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="homology-calc"></div>

                <div class="env-block example">
                    <div class="env-title">Example 6.12 (Homology of Torus T²)</div>
                    <div class="env-body">
                        <p>For \\(T^2 = S^1 \\times S^1\\):
                        \\[H_0(T^2) = \\mathbb{Z}, \\quad H_1(T^2) = \\mathbb{Z}^2, \\quad H_2(T^2) = \\mathbb{Z}, \\quad H_k(T^2) = 0 \\text{ for } k \\ge 3\\]</p>
                        <p><strong>Interpretation:</strong></p>
                        <ul>
                            <li>\\(H_0 = \\mathbb{Z}\\): one component</li>
                            <li>\\(H_1 = \\mathbb{Z}^2\\): two independent loops (meridian and longitude)</li>
                            <li>\\(H_2 = \\mathbb{Z}\\): the whole surface is a 2-cycle</li>
                        </ul>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.13 (Homology of ℝP²)</div>
                    <div class="env-body">
                        <p>For the real projective plane \\(\\mathbb{RP}^2\\):
                        \\[H_0(\\mathbb{RP}^2) = \\mathbb{Z}, \\quad H_1(\\mathbb{RP}^2) = \\mathbb{Z}/2\\mathbb{Z}, \\quad H_2(\\mathbb{RP}^2) = 0\\]</p>
                        <p><strong>Key observation:</strong> The non-orientability shows up as <em>torsion</em> in \\(H_1\\). There is a "half-twist" loop whose double is a boundary.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.14 (Euler Characteristic via Homology)</div>
                    <div class="env-body">
                        <p>For a finite simplicial complex \\(K\\),
                        \\[\\chi(K) = \\sum_{n=0}^\\infty (-1)^n b_n(K) = \\sum_{n=0}^\\infty (-1)^n \\text{rank}(H_n(K))\\]
                        where \\(b_n\\) are the Betti numbers.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof Sketch</div>
                    <div class="env-body">
                        <p>By the rank-nullity theorem applied to the chain complex:
                        \\[\\sum (-1)^n \\dim C_n = \\sum (-1)^n (\\dim Z_n + \\dim B_{n-1})\\]
                        Using \\(\\dim Z_n = \\dim H_n + \\dim B_n\\), the boundary terms telescope, leaving \\(\\sum (-1)^n \\dim H_n\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.15 (Verification for Torus)</div>
                    <div class="env-body">
                        <p>For \\(T^2\\): \\(H_0 = \\mathbb{Z}\\), \\(H_1 = \\mathbb{Z}^2\\), \\(H_2 = \\mathbb{Z}\\).</p>
                        <p>\\(\\chi(T^2) = b_0 - b_1 + b_2 = 1 - 2 + 1 = 0\\). ✓</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'homology-calc',
                    title: 'Homology Calculator',
                    description: 'Input simplicial complex, get Hₙ',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 400;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let selectedExample = 's1';

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.innerHTML = '';
                        body.appendChild(info);

                        const s1Btn = document.createElement('button');
                        s1Btn.textContent = 'S¹ (Circle)';
                        s1Btn.onclick = () => {
                            selectedExample = 's1';
                            draw();
                        };
                        controls.appendChild(s1Btn);

                        const s2Btn = document.createElement('button');
                        s2Btn.textContent = 'S² (Sphere)';
                        s2Btn.onclick = () => {
                            selectedExample = 's2';
                            draw();
                        };
                        controls.appendChild(s2Btn);

                        const torusBtn = document.createElement('button');
                        torusBtn.textContent = 'T² (Torus)';
                        torusBtn.onclick = () => {
                            selectedExample = 'torus';
                            draw();
                        };
                        controls.appendChild(torusBtn);

                        const rp2Btn = document.createElement('button');
                        rp2Btn.textContent = 'ℝP²';
                        rp2Btn.onclick = () => {
                            selectedExample = 'rp2';
                            draw();
                        };
                        controls.appendChild(rp2Btn);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const w = canvas.width;
                            const h = canvas.height;

                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '16px monospace';

                            let homology = {};
                            let chi = 0;
                            let name = '';

                            if (selectedExample === 's1') {
                                name = 'S¹ (Circle)';
                                homology = {H0: 'ℤ', H1: 'ℤ', H2: '0'};
                                chi = 0;
                            } else if (selectedExample === 's2') {
                                name = 'S² (Sphere)';
                                homology = {H0: 'ℤ', H1: '0', H2: 'ℤ', H3: '0'};
                                chi = 2;
                            } else if (selectedExample === 'torus') {
                                name = 'T² (Torus)';
                                homology = {H0: 'ℤ', H1: 'ℤ²', H2: 'ℤ', H3: '0'};
                                chi = 0;
                            } else if (selectedExample === 'rp2') {
                                name = 'ℝP² (Projective Plane)';
                                homology = {H0: 'ℤ', H1: 'ℤ/2ℤ', H2: '0'};
                                chi = 1;
                            }

                            ctx.fillText(`Homology of ${name}`, 50, 50);

                            let y = 100;
                            for (let key in homology) {
                                ctx.fillStyle = '#58a6ff';
                                ctx.font = '14px monospace';
                                ctx.fillText(`${key}:`, 70, y);
                                ctx.fillStyle = '#3fb950';
                                ctx.fillText(homology[key], 150, y);
                                y += 30;
                            }

                            ctx.fillStyle = '#f0883e';
                            ctx.font = '14px monospace';
                            ctx.fillText(`Euler characteristic χ = ${chi}`, 70, y + 20);

                            // Betti numbers
                            ctx.fillStyle = '#8b949e';
                            ctx.font = '12px monospace';
                            y += 60;
                            ctx.fillText('Betti numbers: bₙ = rank(Hₙ)', 70, y);
                            if (selectedExample === 'torus') {
                                ctx.fillText('b₀ = 1, b₁ = 2, b₂ = 1', 70, y + 20);
                                ctx.fillText('χ = 1 - 2 + 1 = 0', 70, y + 40);
                            } else if (selectedExample === 'rp2') {
                                ctx.fillText('b₀ = 1, b₁ = 0 (torsion!), b₂ = 0', 70, y + 20);
                                ctx.fillText('χ = 1 - 0 + 0 = 1', 70, y + 40);
                            }
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Compute \\(H_*(S^2 \\vee S^1)\\) (sphere wedge circle).',
                    hint: 'Use the fact that wedge sums have \\(\\tilde{H}_n(X \\vee Y) = \\tilde{H}_n(X) \\oplus \\tilde{H}_n(Y)\\).',
                    solution: '\\(H_0(S^2 \\vee S^1) = \\mathbb{Z}\\) (one component). \\(H_1(S^2 \\vee S^1) = H_1(S^2) \\oplus H_1(S^1) = 0 \\oplus \\mathbb{Z} = \\mathbb{Z}\\). \\(H_2(S^2 \\vee S^1) = H_2(S^2) \\oplus H_2(S^1) = \\mathbb{Z} \\oplus 0 = \\mathbb{Z}\\). Higher homology vanishes.'
                },
                {
                    question: 'Verify the Euler characteristic formula for \\(\\mathbb{RP}^2\\).',
                    hint: 'Use \\(\\chi = \\sum (-1)^n b_n\\) and account for torsion.',
                    solution: '\\(H_0(\\mathbb{RP}^2) = \\mathbb{Z}\\), \\(H_1(\\mathbb{RP}^2) = \\mathbb{Z}/2\\mathbb{Z}\\) (torsion, rank 0), \\(H_2(\\mathbb{RP}^2) = 0\\). Betti numbers: \\(b_0 = 1, b_1 = 0, b_2 = 0\\). Thus \\(\\chi = 1 - 0 + 0 = 1\\). A minimal triangulation has \\(V = 6, E = 15, F = 10\\), giving \\(\\chi = 6 - 15 + 10 = 1\\). ✓'
                }
            ]
        },

        {
            id: 'reduced-homology',
            title: 'Reduced Homology H̃ₙ',
            content: `
                <h2>Reduced Homology and Augmentation</h2>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.16 (Augmentation Map)</div>
                    <div class="env-body">
                        <p>Define the <strong>augmentation map</strong> \\(\\epsilon: C_0(K) \\to \\mathbb{Z}\\) by:
                        \\[\\epsilon\\left(\\sum a_v [v]\\right) = \\sum a_v\\]
                        (sum of all coefficients).</p>
                        <p>Extend the chain complex: \\(\\cdots \\to C_1 \\xrightarrow{\\partial_1} C_0 \\xrightarrow{\\epsilon} \\mathbb{Z} \\to 0\\).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.17 (Reduced Homology)</div>
                    <div class="env-body">
                        <p>The <strong>reduced homology groups</strong> are:
                        \\[\\tilde{H}_n(K) = \\begin{cases} \\ker \\epsilon / \\text{im} \\partial_1 & n = 0 \\\\ H_n(K) & n \\ge 1 \\end{cases}\\]</p>
                        <p>In other words, \\(\\tilde{H}_0(K) = H_0(K) / \\mathbb{Z}\\) (one rank less).</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Why Reduce?)</div>
                    <div class="env-body">
                        <p>Reduced homology makes formulas cleaner. For instance:</p>
                        <ul>
                            <li>\\(\\tilde{H}_*(\\text{pt}) = 0\\) (all degrees), whereas \\(H_0(\\text{pt}) = \\mathbb{Z}\\)</li>
                            <li>\\(\\tilde{H}_n(X \\vee Y) = \\tilde{H}_n(X) \\oplus \\tilde{H}_n(Y)\\) (exact, no \\(H_0\\) correction)</li>
                        </ul>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.18 (Reduced Homology of Sⁿ)</div>
                    <div class="env-body">
                        <p>For \\(S^n\\):
                        \\[\\tilde{H}_k(S^n) = \\begin{cases} \\mathbb{Z} & k = n \\\\ 0 & k \\neq n \\end{cases}\\]</p>
                        <p>(Compare: \\(H_0(S^n) = \\mathbb{Z}\\), but \\(\\tilde{H}_0(S^n) = 0\\).)</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="betti-counter"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.19 (Relationship H and H̃)</div>
                    <div class="env-body">
                        <p>For path-connected \\(K\\):
                        \\[H_0(K) \\cong \\tilde{H}_0(K) \\oplus \\mathbb{Z}\\]
                        and \\(H_n(K) = \\tilde{H}_n(K)\\) for \\(n \\ge 1\\).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'betti-counter',
                    title: 'Betti Number Counter',
                    description: 'Visualize Betti numbers for different spaces',
                    setup: function(body, controls) {
                        const canvas = document.createElement('canvas');
                        canvas.width = body.clientWidth;
                        canvas.height = 350;
                        body.appendChild(canvas);

                        const ctx = canvas.getContext('2d');
                        let selectedSpace = 'sphere';

                        const info = document.createElement('div');
                        info.style.marginTop = '10px';
                        info.style.color = '#c9d1d9';
                        info.innerHTML = '';
                        body.appendChild(info);

                        const sphereBtn = document.createElement('button');
                        sphereBtn.textContent = 'S²';
                        sphereBtn.onclick = () => { selectedSpace = 'sphere'; draw(); };
                        controls.appendChild(sphereBtn);

                        const torusBtn = document.createElement('button');
                        torusBtn.textContent = 'T²';
                        torusBtn.onclick = () => { selectedSpace = 'torus'; draw(); };
                        controls.appendChild(torusBtn);

                        const genusBtn = document.createElement('button');
                        genusBtn.textContent = 'Genus 2';
                        genusBtn.onclick = () => { selectedSpace = 'genus2'; draw(); };
                        controls.appendChild(genusBtn);

                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const w = canvas.width;
                            const h = canvas.height;

                            let betti = [];
                            let name = '';
                            let chi = 0;

                            if (selectedSpace === 'sphere') {
                                name = 'S²';
                                betti = [1, 0, 1];
                                chi = 2;
                            } else if (selectedSpace === 'torus') {
                                name = 'T²';
                                betti = [1, 2, 1];
                                chi = 0;
                            } else if (selectedSpace === 'genus2') {
                                name = 'Genus 2 Surface';
                                betti = [1, 4, 1];
                                chi = -2;
                            }

                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '16px monospace';
                            ctx.fillText(`Betti Numbers of ${name}`, 50, 40);

                            // Bar chart
                            const barWidth = 60;
                            const maxHeight = 150;
                            const startX = 100;
                            const baseY = h - 80;

                            betti.forEach((b, i) => {
                                const barHeight = b * maxHeight / Math.max(...betti, 1);
                                const x = startX + i * (barWidth + 30);

                                // Bar
                                ctx.fillStyle = ['#58a6ff', '#3fb950', '#bc8cff'][i % 3];
                                ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);

                                // Value
                                ctx.fillStyle = '#c9d1d9';
                                ctx.font = '14px monospace';
                                ctx.fillText(b.toString(), x + barWidth/2 - 5, baseY - barHeight - 10);

                                // Label
                                ctx.fillText(`b${i}`, x + barWidth/2 - 10, baseY + 20);
                            });

                            // Euler characteristic
                            ctx.fillStyle = '#f0883e';
                            ctx.font = '14px monospace';
                            ctx.fillText(`χ = ${betti[0]} - ${betti[1]} + ${betti[2]} = ${chi}`, 50, h - 20);
                        }

                        draw();
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that \\(\\tilde{H}_*(X \\vee Y) \\cong \\tilde{H}_*(X) \\oplus \\tilde{H}_*(Y)\\).',
                    hint: 'Use the fact that \\(C_*(X \\vee Y) = C_*(X) \\oplus C_*(Y)\\) (chains in wedge sum decompose).',
                    solution: 'Since \\(X \\vee Y\\) is the quotient of \\(X \\sqcup Y\\) with basepoints identified, chains decompose: \\(C_n(X \\vee Y) \\cong C_n(X) \\oplus C_n(Y)\\) modulo basepoint. The boundary operator splits: \\(\\partial(c_X, c_Y) = (\\partial c_X, \\partial c_Y)\\). Thus \\(\\tilde{H}_n(X \\vee Y) = \\ker \\partial / \\text{im} \\partial \\cong (\\ker \\partial_X \\oplus \\ker \\partial_Y) / (\\text{im} \\partial_X \\oplus \\text{im} \\partial_Y) \\cong \\tilde{H}_n(X) \\oplus \\tilde{H}_n(Y)\\).'
                },
                {
                    question: 'Compute \\(\\tilde{H}_*(S^1 \\vee S^2)\\).',
                    hint: 'Use the wedge sum formula.',
                    solution: '\\(\\tilde{H}_n(S^1 \\vee S^2) = \\tilde{H}_n(S^1) \\oplus \\tilde{H}_n(S^2)\\). We have \\(\\tilde{H}_1(S^1) = \\mathbb{Z}\\), \\(\\tilde{H}_2(S^2) = \\mathbb{Z}\\), all others zero. Thus: \\(\\tilde{H}_0 = 0\\), \\(\\tilde{H}_1 = \\mathbb{Z}\\), \\(\\tilde{H}_2 = \\mathbb{Z}\\), \\(\\tilde{H}_n = 0\\) for \\(n \\ge 3\\).'
                }
            ]
        }
    ]
});
